<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>消息队列 | 黯淡的晨</title><meta name="author" content="黯淡的晨"><meta name="copyright" content="黯淡的晨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="消息队列-初始篇学习任何东西需要先有一个整体的认识，然后再深入学习，钻研细节，最后再抓住核心脉络，总结整理消化在自己脑海中形成体系。 就好比阅读一些经典书籍，先粗读（建立大概的认识）、后细读（深入去学习思考）、最后总结整理（消化变成自己的东西）。 从RocketMQ的入手，来看看企业级消息队列的整体设计架构。 市面上消息队列的设计基本上八九不离之，在知晓 RocketMQ 的大体设计后对其他消息队">
<meta property="og:type" content="article">
<meta property="og:title" content="消息队列">
<meta property="og:url" content="http://example.com/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="黯淡的晨">
<meta property="og:description" content="消息队列-初始篇学习任何东西需要先有一个整体的认识，然后再深入学习，钻研细节，最后再抓住核心脉络，总结整理消化在自己脑海中形成体系。 就好比阅读一些经典书籍，先粗读（建立大概的认识）、后细读（深入去学习思考）、最后总结整理（消化变成自己的东西）。 从RocketMQ的入手，来看看企业级消息队列的整体设计架构。 市面上消息队列的设计基本上八九不离之，在知晓 RocketMQ 的大体设计后对其他消息队">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/%E6%98%9F%E7%A9%BA.jpg">
<meta property="article:published_time" content="2023-06-14T04:15:41.000Z">
<meta property="article:modified_time" content="2023-06-20T06:49:07.742Z">
<meta property="article:author" content="黯淡的晨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E6%98%9F%E7%A9%BA.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: 黯淡的晨","link":"Link: ","source":"Source: 黯淡的晨","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '消息队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 14:49:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E7%B4%AB%E7%81%B5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E6%98%9F%E7%A9%BA.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">黯淡的晨</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">消息队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-06-14T04:15:41.000Z" title="Created 2023-06-14 12:15:41">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="消息队列"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="消息队列-初始篇"><a href="#消息队列-初始篇" class="headerlink" title="消息队列-初始篇"></a>消息队列-初始篇</h1><p><strong>学习任何东西需要先有一个整体的认识，然后再深入学习，钻研细节，最后再抓住核心脉络，总结整理消化在自己脑海中形成体系。</strong></p>
<p>就好比阅读一些经典书籍，先粗读（建立大概的认识）、后细读（深入去学习思考）、最后总结整理（消化变成自己的东西）。</p>
<p>从RocketMQ的入手，来看看企业级消息队列的整体设计架构。</p>
<p>市面上消息队列的设计基本上八九不离之，在知晓 RocketMQ 的大体设计后对其他消息队列也就手到擒来了。</p>
<p>不过在此之前，我们先自己来思考下：<strong>完整的消息队列到底需要考虑哪些组件？</strong></p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<ul>
<li>producer 就类似上面的我，yes</li>
<li>producer group-A 就类似于yes团队。</li>
<li>nameSrv1、2 类似于看板。</li>
<li>BrokerA、B类似于中转站1、2</li>
<li>BrokerCluster 就是中转站们</li>
<li>consumer 就类似于上面的张三</li>
<li>consumer group-A 就类似于张三团队。</li>
</ul>
<p>我先来简单介绍下。</p>
<h2 id="消息队列的组件"><a href="#消息队列的组件" class="headerlink" title="消息队列的组件"></a>消息队列的组件</h2><p><strong>producer</strong></p>
<p>生产者，就是消息的发送者。</p>
<p>它会将消息发送给 Broker。</p>
<p><strong>producer group</strong></p>
<p>顾名思义，生产者组，它用于标识一类生产者。</p>
<p>比如发送事务消息时，当一个生产者挂了后，broker 可以找同一个生产组里的另一个生产者来确认事务的情况（这里不理解没事，后面文章会介绍到）。</p>
<p><strong>nameSrv</strong></p>
<p>名字服务，上面的例子把它类比为一个看板，实际上它就是一个路由注册中心。</p>
<p>Broker 会把定时自己的信息比如 IP 地址等上传给 nameSrv。</p>
<p>这样生产者和消费者就可以从 nameSrv 上获取这些信息，这样才能顺利的发送和接收消息。</p>
<p><strong>Broker</strong></p>
<p>代理服务器，也就是我说的消息中转站，它主要负责消息的存储、投递、查询。</p>
<p><strong>Broker cluster</strong></p>
<p>代理服务器集群，我们都知道一个服务是脆弱的，假设就一个broker，万一出事了消息就无法正常的发送、存储和消费。</p>
<p>所以我们在企业级场景会搭设集群。</p>
<p>集群可以是主主集群，即集群内部的Broker是同等的，同时对外提供服务。</p>
<p>也可以是主从集群，主 Boroker 对外提供服务，从 Broker 同步主 Boroker 的消息作为备份，当主Broker宕机，从Broker可以提供消费消息。一个主可以有多个从。</p>
<p>关于集群更多高可用和高可靠的内容，我们后续再谈。</p>
<p><strong>consumer 和 consumer group</strong></p>
<p>消费者，用来消费消息。</p>
<p>可以向 Broker 拉取自己想要消费的消息。</p>
<p>可以让 Broker 把自己想要的消息推过来（实际上不是，先假装是）。</p>
<p>然后消费者们可以组成消费组，就像张三小团队。</p>
<p><strong>消费组的概念很关键，比如现在一共有两个消费组分别是张三消费组和李四消费组。</strong></p>
<p>那么两个消费组之间的消息消费是互不干扰的。</p>
<p>就好比我就发了一条消息给 Broker，这条消息张三消费组能看，李四消费组也能看。</p>
<p>那么这条消息被张三消费组消费了，不影响它再被李四消费组消费。</p>
<p>假设我今天连发了 100 条消息，鱼皮很忙，他的消费组可能只看了10条，而猪皮他们很空把 100条都看了，这不会影响明天鱼皮接着看剩下的 90 条消息，这好比消息被复制了一份，鱼皮组和猪皮组各看各的。</p>
<p>然后对于一个组来说，消费的模式有集群消费和广播消费两种模式。</p>
<ul>
<li>集群模式：生产者发送了 4 条消息，编号分别是A-D，鱼皮团队接收了这 4 条消息，实际上是鱼皮收到了A、D，鱼皮-1 收到了 B，鱼皮-2 收到了 C，大家负载均衡地消费了这 4 条消息。</li>
<li>广播模式：生产者发送了 4 条消息，编号分别是A-D，鱼皮团队接收了这 4 条消息，实际上是鱼皮收到了A、B、C、D，鱼皮-1收到了A、B、C、D，鱼皮-2收到了A、B、C、D，组内的每个消费组都收到了全部消息，这就是广播。</li>
</ul>
<p><strong>Topic</strong></p>
<p>就是主题，可以认为是消息的分类。</p>
<p>比如足球主题，篮球主题。</p>
<p>那么有关足球的消息，我都发往足球主题，如Topic-football；有关篮球的消息，我都发往篮球主题，如 Topic-basketball。</p>
<p>这样就给消息分了类，那么对足球有兴趣的消费者则可以订阅Topic-football、对篮球有兴趣的则订阅Topic-basketball，大家相互之间互不干扰。</p>
<p>这样一来大家都只订阅自己想要的消息，不会被无关的消息给冲烂了。</p>
<p><strong>Tag</strong> </p>
<p>Topic已经给消息分类了，那么tag类似于二级分类，这能更精细化地区分消息。</p>
<p>比如有人对足球主题感兴趣，但是只喜欢看梅西相关的消息，而有些人喜欢看C 罗的消息。</p>
<p>那么发送消息是往足球主题发，但是也顺带上了tag信息来标记这个消息是梅西的还是C罗的。</p>
<p>这样订阅了足球主题的消费组可以根据tag选择它们想要的消息，过滤它们不想要的消息。</p>
<p>比如鱼皮喜欢梅西，那么订阅的时候标记自己只要Topic-football 且tag 是梅西的消息。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>不同的消费组可以消费同Topic的消息，它们之间的消费进度又可以不一样，那是 Broker 将消息复制了多份吗？</p>
<p>如果有上百个消费组，岂不是有复制上百份一模一样的消息？这样合理吗？你有更好的解决方式吗？</p>
<h1 id="消息队列-必须掌握的两个基础模式"><a href="#消息队列-必须掌握的两个基础模式" class="headerlink" title="消息队列-必须掌握的两个基础模式"></a>消息队列-必须掌握的两个基础模式</h1><p>上篇介绍了消息队列的基础概念和RocketMQ整体设计架构。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>这篇我们来盘一盘其中的细节，这关系到消息队列的两个不同的实现模式。</p>
<h2 id="队列模式"><a href="#队列模式" class="headerlink" title="队列模式"></a>队列模式</h2><p>我们都知道队列是一种数据结构，它的特性是先进先出，就跟我们平时在食堂打饭排队一样，排在前面的同学打完饭了就走了，后面的同学顶上去打饭。</p>
<p>而消息队列，直观来看就是消息排成了队列，被消费了，这个消息就出队了，后续的消息顶上。</p>
<p>一开始的消息队列就是这样设计的，生产者发送的消息被排成队列，然后消费者们竞争消费队列上的消息。</p>
<p>为什么称之为竞争？</p>
<p>按照队列的特性，消息被消费了等于出队，即从队列上被移除了，那么每条消息只会被一个消费者消费，因此消费者之间是竞争关系。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-1.png"></p>
<p>这个特性很符合初期的需求，一个消息被消费了，自然就应该被移除，不要堵在那里影响后续的消息被消费。</p>
<p>这叫队列模式。</p>
<p>这样的设计在早期没问题，但是随着互联网演进，系统的复杂性不断提升，随之而来的需求也更加繁琐。</p>
<p>就像一个消息可能有很多消费者都感兴趣，但是他们之间又不是竞争消费的关系，即这些消费者都想消费所有的消息。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-2.png"></p>
<p>这时候队列模式是不是就不合适了？因为队列的设计是消息被消费了就出队，而出队了如何再被别的消费者消费呢？</p>
<p>很自然地我们会想到把消息复制成多份，也就是多队列！</p>
<p>这样一条消息被冗余到多个队列中，每个队列都包含全量的消息，这就满足了这些不是竞争关系的消费者们的需求。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-3.png"></p>
<p>但这样的方式对存储就不是很友好了，因为随着消费者们的增加，队列会越来越多，冗余的消息也就越来越多。</p>
<p>于是就逐步演进，出现了发布-订阅模式。</p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>其实从名字上我们已经能感受到区别了。生产者发布消息，消费者订阅消息，订阅的依据是啥？就是我前面提到的 Topic（主题）。</p>
<p>发布-订阅模式想要实现的功能是：比如我往 Topic-LOL 这个主题发布消息，那么订阅了这个主题的消费者都能收到这个消息，我往Topic-DOTA这个主题发布消息，那么订阅了DOTA主题的消费者都能收到 DOTA 相关的消息。</p>
<p>从概念上发布-订阅模式完美契合一个消息可以被多个消费者同时消费的诉求。</p>
<p>那具体是如何实现的呢？</p>
<p>这里就需要引入<strong>消息位置（offset）</strong>的概念，这个概念你可以类比理解为数组的下标。</p>
<p>我们的述求是消息可以被多个消费者消费，那么<strong>只需维护每个消费者已经消费到的位置，每当消费者消费一条消息，消费位置就+1</strong>，然后消费者根据记录的消息位置去消费对应的数据即可。</p>
<p>就跟遍历数组一样，下标+1来访问后面的数据。</p>
<p>这样就能满足不同消费者消费同一条消息，且不影响他们之间的消费进度的需求。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-4.png"></p>
<p>如上图所示，我们只需要分别记录以下的消息位置即可：</p>
<ul>
<li>Topic-LOL-鱼皮-3</li>
<li>Topic-LOL-猪皮–5</li>
<li>Topic-DOTA-鱼皮-1</li>
<li>Topic-DOTA-猪皮-4</li>
</ul>
<p>当鱼皮消费完Topic-LOL第三条消息后，将位置+1，3+1等于4，这样就能顺利访问第四条消息。</p>
<p>假如后面又加个了蛇皮来消费消息，我们也不需要复制消息，只需要多一个蛇皮的消息位置记录即可。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-5.png"></p>
<p>这样即使消费者很多，对存储的也没什么影响。</p>
<p>初步来看问题得以解决，但是还记得我们上篇文章提到的消费者组的概念吗？</p>
<p>就像鱼皮一个人忙不过来所以组成了自己的小团队，一个消费者单独消费Topic的速度有限，于是乎形成了消费组的概念，消费组内的消费者共同分担消费 Topic 中信息。</p>
<p>那么问题来了。</p>
<p>同一个消费组内的消费者如何消费消息呢？</p>
<p>让他们竞争同一个消费位置吗？那岂不是需要等上一个消费者消费完了，组内其他消费者才能消费下一条消息？</p>
<p>这效率就很低了。</p>
<p>所以这里还需要引入一个概念，<strong>在 RocketMQ 中叫队列（这个跟数据结构上的队列在概念上要区分下），在Kafka中叫分区</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-6.png"></p>
<p>可以看到，发往一个 Topic 的消息，实际上不是在一个队列里，而是分布在多个队列中。</p>
<p>这样属于一个消费组的消费者们可以专门负责主题里面的一个队列，比如下图：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-7.png"></p>
<p>然后我们消费点位的<strong>记录维度就变成了 Topic-消费组-队列</strong>，比如现在一共有两个主题，分别是Topic-LOL、Topic-DOTA，每个主题都有两个队列（分区）。</p>
<p>现在有两个消费组分别是鱼皮组、猪皮组。</p>
<p>鱼皮组一共有两个消费者分别是鱼皮-1，鱼皮-2。</p>
<p>猪皮组也有两个消费者分别是猪皮-1，猪皮-2。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-8.png"></p>
<p>如上图所示，那么消费位置记录如下：</p>
<ul>
<li>Topic-LOL-鱼皮组-队列1-3</li>
<li>Topic-LOL-鱼皮组-队列2-4</li>
<li>Topic-LOL-猪皮组-队列1-1</li>
<li>Topic-LOL-猪皮组-队列2-3</li>
<li>Topic-DOTA-鱼皮组-队列1-1</li>
<li>Topic-DOTA-鱼皮组-队列2-2</li>
<li>Topic-DOTA-猪皮组-队列1-3</li>
<li>Topic-DOTA-猪皮组-队列2-4</li>
</ul>
<p>这样一来，我们就完美解决了之前队列模式一个消息只能被一个消费者消费的问题，也实现了消费组之间的消费互不影响，且消费组内多个消费者之间的消费也互不影响。</p>
<p>这个模式就很完美。</p>
<p>如果鱼皮组扩张了，比如又招了一个人，鱼皮-3，那此时咋办呢？我们对应的主题也可以增加一个队列，比如 Topic-LOL：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-9.png"></p>
<p>但猪皮组还是两人，现在有三个队列咋办？</p>
<p>影响不大，只要猪皮1同时消费队列-1、队列-3就行了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2-10.png"></p>
<p>这个方案非常灵活，加队列同时加消费者的处理方式就是消息堆积的一个解决办法之一（面试常问，后续补充）</p>
<p>至此，我们就清晰了企业级消息队列实现的发布-订阅模式的<strong>核心原理：即 Topic 下分队列（分区），然后维护每个消费组在每个 Topic 下每个队列的消息位置，以消息位置（offset）来控制消息消费的进度。</strong></p>
<p>消息位置的灵活性不仅仅能区分不同消费组或者说消费者们的消费进度，还能<strong>实现重复消费或者跳过部分消息不消费的功能。</strong></p>
<p>比如鱼皮-1已经消费到 Topic-LOL-队列1-20，即第 20 条消息，但是鱼皮1一不小心把之前关于Topic-LOL的消费得到的结果数据弄丢了，如果按照队列模式那就找不到消息了，因为消息已经出队了没了。</p>
<p>而在发布-订阅模式中，我们仅需把这个消息位置变更成Topic-LOL-队列1-0，这样又可以让鱼皮-1重新消费，只需要简单地改一条数据就能实现这样功能。</p>
<p>假设Topic-LOL-队列-1中第21-30这10条消息是错误的，我们可以修改当前的消息点位成Topic-LOL-队列1-30，这样鱼皮-1 就直接跳过了这 10 条错误消息，从第31 条消息开始消费，你看是不是非常灵活？</p>
<p>这个模式是不是很棒！</p>
<h2 id="生产者如何确定消息发往哪个队列？"><a href="#生产者如何确定消息发往哪个队列？" class="headerlink" title="生产者如何确定消息发往哪个队列？"></a>生产者如何确定消息发往哪个队列？</h2><p>现在再让我们把视线从消费者转到生产者。</p>
<p>一个 Topic 里面有多个队列，那么生产者怎么知道要发到哪个队列？</p>
<p>一个很简单的办法就是轮询，比如生产者-A，要往Topic-LOL发送消息，那么第一条发给队列-1，第二条发给队列-2，第三条发给队列-3，第四条发给队列-1，第五条发给队列-2。。。。如此往复即可。</p>
<p>这样每个队列的消息量会很平均，对应的消费者的工作量也会均衡。</p>
<p>当然也可以指定发往某个队列，比如有关匹配的消息都发往队列-1，有关大乱斗的消息都发往队列-2，有关云顶之弈的消息都发给队列-3。</p>
<p>有关于这块的内容后续我们再详谈，现在大概知晓一下即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了消息队列的两个基础模式，分别是：队列模式和发布-订阅模式。</p>
<p><strong>RabbitMQ 的底层就是队列模式，而 RocketMQ 和 Kafka 两者的实现都是发布-订阅模式。</strong></p>
<p>后续介绍市面上常见MQ中间件的特性，现在先打好基础。</p>
<p>着重掌握发布-订阅模式，这对后续进阶的消息负载均衡、顺序消息等很关键。</p>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><ol>
<li><p>上文其实已经隐约提出了消息队列提高并发的方案，可以用你自己的话来总结一下如何提高消息并发吗？</p>
</li>
<li><p>某个主题下有两个队列，对应的消费组也有两个消费者，如果此时增加一个消费者，那么能加快整体消费组对这个主题的消费速度吗？</p>
</li>
</ol>
<h1 id="消息队列-核心之存储（1）"><a href="#消息队列-核心之存储（1）" class="headerlink" title="消息队列-核心之存储（1）"></a>消息队列-核心之存储（1）</h1><p>经过前面两篇文章，我们已经总览了一个企业级消息队列中间件该有的架构，也清晰了消息队列的两个基础模式，明白了消费组等基础概念。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>这篇我们要深入了解 Broker 关于消息的存储到底是如何实现的。</p>
<p>消息的存储非常重要，因为消息队列有一个很关键的功能就是<strong>削峰填谷</strong>，简单来说就是在大流量（如双十一场景），一下子涌入太多的用户，造成了请求高峰，使得系统压力剧增。</p>
<p>这时候一个很好的办法就是把相关请求先发送至消息队列，然后直接返回给用户成功，诸如：“业务受理成功，由于当前流量较高，到账时间约xx-xx分钟”这样的话术。</p>
<p>然后让系统平缓、匀速地拿取消息队列里面的消息进行业务处理。</p>
<p>而这就需要<strong>保证排队的消息存储的可靠性</strong>。</p>
<p>比如现在排了1000条消息，那我们最后必须要能处理到这 1000条消息，不能处理了500条消息，然后消息队列突发重启了，后面500条消息就没了，那可就G了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-1.png"></p>
<p>所以我们需要来思考下：Broker 里的消息，到底该存在哪？</p>
<h2 id="消息存哪？"><a href="#消息存哪？" class="headerlink" title="消息存哪？"></a>消息存哪？</h2><p>存储数据一般我们第一个想到的是数据库，比如MySQL。</p>
<p>所以把消息存储到数据库里？</p>
<p>这不太合适。</p>
<p>上面说了消息队列需要满足削峰填谷的需求，也就是消息存储的性能要好，快速存储消息返回存储结果，这样才不会堵塞业务处理。<br>不然存个消息要半天，那跟直接处理业务有什么区别？别谈什么削峰了，自己就是那座峰。</p>
<p>那把消息存入数据库性能好吗？</p>
<p>众所周知，性能不好，性能要是好还要什么缓存？要什么 Redis？</p>
<p>咦，提到 Redis？MySQL这种关系型数据库性能不好，那 Redis 性能总好了吧！</p>
<p>确实，Redis 性能是 ok 的，但是它不可靠啊！</p>
<p>上面已经说了，存储到消息队列的消息，一定需要保证它能被消费到，这样才不会影响正常业务，如果存储不可靠，丟了消息，麻烦就大了！</p>
<p>而且，不论是依赖MySQL还是Redis或其他三方存储组件，都会增加消息队列这个中间件本身的复杂度和运维难度。</p>
<p>任何一件东西，只要依赖的东西变多，它就会变复杂，而复杂意味着容易出错，在工程上容易出错就容易造成线上事故，造成线上事故就等着挨批、记过、低绩效。</p>
<p><strong>轻则没年终奖钱包变瘪，重则劝退让你毕业</strong>。</p>
<p>这里插一句题外话：有时候炫技固然很酷，但是真正在工作中切记不要过度设计、不要复杂化系统，一切先追求最简单的实现方式，这样更高效。</p>
<p>这里的高效不仅体现在实现需求时候的高效率，万一线上出了问题，也能更迅速的排查和解决问题，及时止损。</p>
<p>说回消息队列，对于一个中间件而言，轻量级也很关键，中间件自身依赖别的组件，就是强行要求使用者熟悉且维护这些被依赖的组件，这对使用者而言要求也会变高，会更复杂。</p>
<p>那还能存哪呢？</p>
<h2 id="本地硬盘！"><a href="#本地硬盘！" class="headerlink" title="本地硬盘！"></a>本地硬盘！</h2><p>MySQL 数据实际存储的地方是本地硬盘，Redis持久化的数据也是存到本地硬盘上。</p>
<p>我们直接绕过它们，不给中间商赚差价，将消息直接写入的本地硬盘的文件上。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-2.png"></p>
<p>这里可能有人会说，硬盘也不可靠啊，硬盘不是会损坏吗？</p>
<p>不用担心，单个硬盘是不可靠，但是现在都已经是 RAID，即多块硬盘组成逻辑上的一块硬盘，简单理解就是有备份，更多的同学们自身查阅，这里不多展开。</p>
<p>我们继续回到消息队列上，既然已经决定了要将消息写入文件，存储在本地硬盘上，那具体要以怎样的格式存储？</p>
<h2 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h2><p>关于将消息以怎样的格式存储到文件里，相信很多同学脑海中跳出来的就是一行一行写咯。</p>
<p>就像记事本的写入：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-3.png"></p>
<p>没错，RocketMQ就是类似这样存储消息的：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-4.png"></p>
<p>这个文件在RocketMQ里面叫 commitlog。</p>
<p>上图的细节我们再来品一品：</p>
<ol>
<li>每条消息的大小是不固定的。</li>
<li>不同topic的消息都存在一个文件里。</li>
</ol>
<p>关于第一点，这毋庸置疑，我们无法强制要求大家发的消息都是一样的字数，这不符合常理。</p>
<p>关于第二点，感觉有点奇怪，为什么要把不同 topic 的消息都存在一个文件里面？</p>
<p>不是应该将不同 topic 消息维护到不同的文件中吗？这样不论在结构上还是业务上都更加清晰。</p>
<p>这里其实涉及到计算机组成原理之机械硬盘结构的特性。</p>
<h2 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h2><p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-5.png"></p>
<p>这是机械硬盘物理结构。</p>
<p>我先简述一下硬盘是怎么运行的：通电之后主轴带动盘片开始旋转，到达一定转速之后磁头就会悬浮在盘片上方，然后磁头臂就可以控制磁头做圆弧形的移动，通过盘片的旋转和磁头的移动就可能访问到盘片上任意地方的数据。</p>
<p>我们简单来看下盘片的结构：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3-6.png"></p>
<ul>
<li>A 就是磁道，盘面就是由磁道这样的一组同心圆构成，注意是标红部位，是个环，有横截面的，有些参考书标记到线上去了….</li>
<li>B 是扇面</li>
<li>C 就是扇区，每个磁道都会被划分成一组扇区，每个扇区包含相等数量的数据位，一般为512字节，是硬盘存储数据最基本的单位。</li>
<li>D 是簇，即多个扇区组成的，像 DOS 就是以簇为单位为文件分配磁盘空间的。</li>
</ul>
<p><strong>如要访问硬盘的数据，就需要将磁头放到对应数据存储的扇区上。</strong></p>
<p>这里关于数据的访问有两个时间概念：</p>
<ol>
<li>寻道时间：盘片的表面是磁性的，盘片随着主轴旋转而转动，当要访问某个扇区的时候首先要转动磁头臂找到对应的磁道。</li>
<li>旋转时间：这时盘片还是在旋转中的，磁头可以感知到下方数据位上的值，等旋转到目标扇区的时候就晓得该读&#x2F;写数据了。</li>
</ol>
<p>所以在物理上，<strong>如果存储在硬盘上的数据在同一个磁道且相邻的扇区，那么根据硬盘的机械运行轨迹，读&#x2F;写的顺序就非常快（省略寻道时间，顺应旋转的方向），甚至可以媲美内存的读写速度！</strong></p>
<p>这就是常常被提到的<strong>顺序读</strong>和<strong>顺序写</strong>。</p>
<p>说了这么多关于机械硬盘的内容跟将不同topic消息都写入一个文件有什么关系吗？</p>
<p>当然有关系！</p>
<p>所有的消息不论是哪个topic都写入同一个文件，并且都是顺序追加写入，那么对应到硬盘上就是顺序写！（基本上一个文件的内容，如果空间足够，那么都是连续的）一这样就大大提高了消息队列写消息的性能。</p>
<p>如果将不同的 topic 存入不同的文件，我们无法保证这些文件在物理上的位置是连续的。</p>
<p>且如果topic很多，那么对应的文件就会很多，那每次写入不同的文件，可能都需要寻不同的道，写不同的扇区，这样速度就很慢，这就是<strong>随机写</strong>。</p>
<p>所以为了保证写入时候的性能，RocketMQ设计所有topic的消息都写到一个文件里。这也是面试常常会问到 RocketMQ 为什么性能好的原因之一：<strong>顺序写</strong>。</p>
<p>一定要牢记顺序写，这个在很多地方都有应用，比如 MySQL 的 redo log。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>最后来总结下这篇文章我想表达的东西：</p>
<ol>
<li><p>对中间件实现而言，架构要精简，尽量避免依赖其他三方组件，这样会增加整体架构的复杂度，对使用者而言上手更加复杂，运维成本更高。</p>
</li>
<li><p>工作上的代码实现，不要过度设计，不要想着炫技，要简单务实，“大道至简”。</p>
</li>
<li><p>学习一个方向（模块化）的知识，不经意间就会涉及到另一个领域，比如我们今天从消息队列存储的顺序读&#x2F;写，延伸到机械硬盘的结构，如果你不知道机械硬盘的运行原理，你肯定无法理解顺序写的好处。</p>
</li>
</ol>
<p>这种知识的交叉是无法避免的，因为像计算机网络、组成原理、操作系统这类都算是基石，我们业务代码、中间件代码都跑在它们之上，所有底层都离不开它们。</p>
<p>这里我想说的不仅是这些基础知识很重要，在模块化学习的时候，切记不要朝三暮四也非常关键！就像今天我们因为顺序读&#x2F;写，不得已要去了解硬盘知识，但我们的目标应该仅了解硬盘有关顺序写的相关知识，然后立马回身继续投入到消息队列的学习中，不要延伸去学习别的方向的知识。</p>
<p>我们可以记录这些疑惑点或好奇点，等模块化知识学习完后再去解决它们。</p>
<p>因为学习最怕就是东学一点，西学一点，这样不成体系，效率非常低，很容易学了后面忘了前面。</p>
<p>这是我这篇文章想表达的一个很重要的观点！学习方法真的很关键！</p>
<p>好了，最后的最后，我们还是需要回到消息队列这个主题上来。</p>
<p>总结下这篇关于RocketMQ的消息写入存储的重点：<strong>RocketMQ选择将消息写入到文件中，依赖机械硬盘（当然也可以是ssd）来保证消息存储的可靠性，并且根据机械硬盘的特性，把不同topic的消息都追加写入到一个叫 commitlog的文件中，这样的顺序写性能很好。</strong></p>
<h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p>我们都已经知道 RocketMQ 中队列的概念，消费者是从队列上消费消息的，那么现在消息都存储在一个叫 commitlog 地方，那队列呢？队列跟 commmitlog 是什么关系？如果获取commitlog里面的消息，是遍历吗？</p>
<h1 id="消息队列-核心之存储（2）"><a href="#消息队列-核心之存储（2）" class="headerlink" title="消息队列-核心之存储（2）"></a>消息队列-核心之存储（2）</h1><p>RocketMQ整体设计架构：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>从前面，我们已经知晓了RocketMQ是将所有的消息（不论是哪个topic）都存入到一个文件-commitlog 中，这样就能利用硬盘<strong>顺序写</strong>的特性，提高消息写入的性能。</p>
<p>而将不同topic都写入到一个地方带来的问题是：<strong>消费者如何快速找到commitlog里面的消息呢？</strong></p>
<p>并且我们前面的文章也提到了队列的概念（提高消费的并发度）：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-1.png"></p>
<p>可以看到，同一个 Topic 下，鱼皮-1 这个消费者消费的是队列1里面的消息，鱼皮-2消费的是队列2里面的消息，这样看来，单单一个 commitlog 好像无法满足这个需求？</p>
<p>那到底是怎样实现的呢？</p>
<h2 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h2><p>在 RocketMQ 对应的有个叫 ConsumeQueue 的玩意，看看这名字，直译过来不就是消费队列的吗？</p>
<p>这玩意就对应上前面提到的那张图里面的队列了。</p>
<p>那这个队列如何跟 commitlog 关联上呢？</p>
<p>我们已经知道消息写入commitlog后，就代表生产者成功发送了这条消息，消息也落入到硬盘中被持久化了。</p>
<p>这时候我们可以启动一个定时任务，将新写入 commitlog 的消息转发给 ConsumeQueue，这样不就实现了多队列的需求了？</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-2.png"></p>
<p>从上图我们可以看到，<strong>不同的topic的消息都存到commitlog中，然后会定时地分发到不同topic对应的ConsumeQueue中，之后消费者可以直接从ConsumeQueue获取消息。</strong></p>
<p>那这个定时分发到底是多久分发一次呢？我从4.x的源码来看是1毫秒。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-3.png"></p>
<p>所以时效性不用担心，基本上是实时的！</p>
<p>但是还有一个问题：<strong>ConsumeQueue 有必要存全量的消息内容吗？</strong></p>
<p>ConsumeQueue 到底存的是啥？</p>
<p>我们最直接的想法肯定是让consumerQueue存储全量的消息内容，这样消费者通过consumerQueue 就能直接拿到消息，非常便捷。</p>
<p>但是这样的实现有个弊端：<strong>存储空间的拮据</strong>。</p>
<p>首先全量消息已经存储在 commitlog 中，此时再复制一份放到 consumerQueue 里，是不是觉得很浪费？</p>
<p>如果本身 commitlog 的消息有 10G，那算上 consumerQueue 不得 20 G了？</p>
<p>这一点都不优雅。</p>
<p>那有什么办法可以节省存储空间，又让消费者能从 consumerQueue 上获取消息呢？</p>
<p>既然全量的消息内容只在 commitlog 中，我们肯定少不了去 commitlog 找消息这个动作，那么如何快速从 commitlog 找到对应的消息就是关键了。</p>
<p>对于查找大量数据，我们下意识地就应该想到索引。</p>
<p>就类似于书的目录。</p>
<p>那具体该如何实现这个索引呢？</p>
<p>我们已经知道消息是直接存储到commitlog中，且是追加写入，而commitlog本身就是一个文件，里面连续存储了消息内容。这里需要引入一个概念：<strong>偏移量</strong>。</p>
<p>我们来举个例子简单理解下这个概念，commitlog里面存储了两条消息，分别是：AA，123，即文件的内容是AA123</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-4.png"></p>
<p>那么偏移量0，连续读两位，我们能拿到AA。</p>
<p>偏移量2，连续读三位，我们能拿到123。</p>
<p>按照这个逻辑，consumerQueue里面仅需要存储一条消息的起始偏移量，再加这条消息的长度，就能快速地拿到这条消息！</p>
<p>看到这里可能会有同学提问：不对啊？假设偏移量很大，比如10000000，那岂不是要持续扫描跳过这么多位才能找到这个消息，那不是应该很慢吗？</p>
<p>不用担心，我们可以拿数组来类比理解，比如你要取数组的第20位数据，我们不是傻傻地从前往后扫描过去的吧？这个道理也是类似的。</p>
<p>因此，consumerQueue 需要存储消息在 commitlog 文件中的起始偏移量和本条消息的长度！</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-5.png"></p>
<p>上图我还画了个tag hash，这个先忽略，后面我们讲到tag 的时候再说。</p>
<p>这样一来，就满足了节省存储空间的需求，当然坏处就是消费消息时，直接从comsumerQueue无法得到完整的消息，得再去commitlog找，多找了一次，增加了查询的开销，但是这也是权衡的结果，也就是时间和空间的互换。</p>
<p><strong>想要时间短，空间需要牺牲，想要空间省，时间上需要牺牲，最终的结果得看需求来权衡。</strong></p>
<p>对了，comsumerQueue也需要<strong>落盘存储</strong>的！毕竟消费者是通过它来获取最终的消息的，可不能一宕机就没了。</p>
<h2 id="consumerOffset"><a href="#consumerOffset" class="headerlink" title="consumerOffset"></a>consumerOffset</h2><p>至此，我们已经知晓 commitlog 和 comsumerQueue，也知晓了 comsumerQueue 实际存储的不是消息本身，而是消息在commitlog文件里面的起始偏移量以及长度（还有taghash）。</p>
<p>这里我们还需要知晓一个概念：consumerOffset。</p>
<p>在这前面<strong>消息队列-必须掌握的两个基础模式</strong>中，我们谈到了消息位置（offset）的概念。在一个队列被多个消费者消费时，只需维护每个消费者已经消费到的位置，每当消费者消费一条消息，消费位置就+1，然后消费者根据记录的消息位置去队列查找消费对应的消息即可。</p>
<p>就跟遍历数组一样，下标+1来访问后面的数据。</p>
<p>也就是通过消费位置来记录我们消费的进度。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-6.png"></p>
<p>在RocketMQ中，这个消费位置的专业名词就叫 consumerOffset。</p>
<p>这个 consumerOffset需要跟前面提到的 commitlog offset 做下区分。</p>
<ul>
<li>consumerOffset：消息逻辑位置，即消费者对于某个队列消费到的位置，如一共有5条消息，此时消费者消费到第3条，那么consumerOffset 就是 3（从0算起那就是2）。（<strong>队列中有多条消息，找到消费到的那条消息</strong>）</li>
<li>commitlog offset：消息所在commitlog文件中的偏移位置，通过这个offset找到消息的起始位置，然后根据size往后读多少位来获取一条消息完整的内容。（<strong>具体消息上存储了commitlog上一条消息的起始位置，大小</strong>）</li>
</ul>
<p>因此，消费者消费一条消息的流程是：<strong>通过 consumerOffset 找到 comsumerQueue 里面的内容，这个内容存储了消息所在commitlog中的偏移量和size，然后再通过这两个数据去commitlog 获取完整的消息内容。</strong></p>
<p>你看，从感觉上我们拿一条消息好像很容易，实际编码实现还是有很多讲究的。</p>
<h2 id="消息索引"><a href="#消息索引" class="headerlink" title="消息索引"></a>消息索引</h2><p>除了commitlog，consumerQueue这两个文件之外，RocketMQ中还有IndexFile。</p>
<p>这个文件存的就是消息的索引。</p>
<p>平日我们如果遇到什么线上问题，如果快速找到定位到一条消息？</p>
<p>用的就是这个索引。</p>
<p>比如跟订单有关的消息，我们就可以将这个 key 设置为订单号，那么出现问题可以很方便的在控制台，比如阿里云的控制台（或者其他组件）来输入订单号搜索到消息相关的内容：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-7.png"></p>
<p>那这个索引文件到底是如何设计的呢？</p>
<p>最直观的想法是设计成一个 HashMap，map 的 key 就是索引的值，value 就是存储对应消息的offset（同consumerQueue节省存储空间）</p>
<p>想法没问题，但是我们是将这些数据存储到文件中的，文件可不提供HashMap的功能，所以需要我们实现一个类似的结构。</p>
<p>那具体在文件里面的结构应该是怎样的？</p>
<p>在 RocketMQ 中，IndexFile 文件的格式如下：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-8.png"></p>
<p><strong>我先来解释一下500w 槽：</strong></p>
<p>每个槽的大小是固定的，4 个字节，一个 indexFile 一共会有500w个槽。</p>
<p>当我们设置一条消息的 key 是：aaa，那么就会计算 hash（topic#aaa）得到一个 hash 值，即keyHash</p>
<p>然后再通过 keyHash%500w，就能得到一个整数，这个整数代表的就是第几个槽。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-9.png"></p>
<p>知道第几个槽之后，槽里面存什么内容呢？</p>
<p>存的就是 index item 的下标！</p>
<p>每个 index item 也是固定大小，20字节，一个 indexFile 文件一共有 2000w 个 index item，它就<strong>存储了消息在commitlog中的物理偏移量</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-10.png"></p>
<p>如上图所示，假设key aaa这是第一条消息，那么第一条消息的index item的下标的位置就是0，所以槽里面的值存的是0。</p>
<p>如果第二条消息来了之后，那么第二条消息的 index item 下标的位置是1，那么第二条消息对应的槽的值存的就是1。</p>
<p>如果第三条消息来了之后，下标的位置是2，那么第三条消息对应的槽的值存的就是 2。</p>
<p>、、、</p>
<p>依次递增+1。</p>
<p>这样存储后，假设我们通过索引 aaa 来查询，那么仅需三步计算（时间复杂。（1）），就能获取到消息的内容。</p>
<ol>
<li>hash（topic#aaa）&#x3D; hashKey</li>
<li>hashKey%5000000 &#x3D;2</li>
<li>indexStartOffset + 2*20 就能找到消息索引存储的值</li>
</ol>
<p>这个 indexStartOffset 是一个固定的值，因为 head 和 500w槽的长度是固定的。</p>
<p>是不是挺巧妙的？</p>
<p>那假设 hash 冲突了怎么办？我们都知道 hash 取余可能会有冲突的！</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-11.png"></p>
<p>这时候，就需要再丰富一下设计！</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4-12.png"></p>
<p>可以看到，解决方式就是更新槽的值为最新的 index item 的下标，即1。</p>
<p>并且在最新插入的 index item 里记录前一个 index item 的下标，即 prevIndex &#x3D; 0（前一个 index item 的下标就是 0）。</p>
<p>而且 index item 内还需要存储 keyhash 值，用来判断跟当前计算的 hash 是否一致。一致说明找到了，不一致说明是冲突的，还需要通过 previndex 值得到的上一个item 的下标去查找。</p>
<p>我来举例说明下：</p>
<p>假设我们还是要通过 key：aaa查，此时定位到的槽是里面的值是 1.</p>
<p>然后我们找到 index item 下标是 1 的值，发现里面存储的 keyhash（之前没有进行&#x2F;500w取模的值） 跟 aaa 计算出来的不一样，那么需要获取 previndex 的值，即 0。</p>
<p>然后找到index item下标是0的值，发现里面的keyhash跟aaa计算出来的一致，那么就是它了，于是拿到物理偏移量去 commitlog 找即可（其实下标为 0肯定就是了，因为是最后一条了，不需要对比）。</p>
<p>index item 里面还存储了个消息的时间，这个时间还是个差值：即这条消息在 commitLog 写入时间-IndexFile 第一条消息的写入时间。</p>
<p>之所以这样设计，是为了节省存储空间，<strong>可以看到一个有追求的中间件在一些细节方面都会做的很好</strong>！</p>
<p>最后还有个 head 没介绍，其实这个 head 存放的就是一些元信息，方便后续的操作：</p>
<ul>
<li>当前文件中消息最小的存储时间</li>
<li>当前文件中消息最大的存储时间</li>
<li>当前文件中消息在 commitlog 最小偏移量</li>
<li>当前文件中消息在 commitlog 最大偏移量</li>
<li>已用 hash 槽个数</li>
<li>已用 index 个数</li>
</ul>
<p>head 的大小也是固定的，因此 indexFile分为了三大块：header、hash槽、index items。</p>
<p>结合上述的信息，我相信你的脑海中已经可以构造出通过消息 key 查询到消息的完成流程图了！</p>
<p>这个文件哈希查找的设计也值得我们细细品味。</p>
<p>对了 indexFile 的构建跟 comsumerQueue 也是一样的，也是从 commitlog 分发过来的。</p>
<p>还有 indexFile 的文件是通过时间戳命名的，包括 head 里面的时间，以及 index item 里面的时间，这样就能提供时间范围的查询，这里就不细说了，有兴趣的同学可以自行查阅相关资料哈。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>其实关于这块有很多细节，包括消息在 commitlog 存储的格式等等，比如xxx几个字节这样的。</p>
<p>这个有兴趣的同学自行去了解，我之所以不介绍这些内容是因为扣这些细节仅在一些排查问题场景有用。</p>
<p>在学习大块知识体系的时候，这些东西只会成为我们的绊脚石，等我们真正全面了解 RocketMQ知识之后，才是关注这些细节的时候（其实不关注也行，基本上没啥大用哈哈）。</p>
<p>今天我们介绍了ConsumeQueue、IndexFile的实现原理、作用以及它们与commitlog的交互。</p>
<p>相信你已经可以将这部分流程通过一张流程图串连起来。</p>
<h1 id="消息队列-核心之消息的发送"><a href="#消息队列-核心之消息的发送" class="headerlink" title="消息队列-核心之消息的发送"></a>消息队列-核心之消息的发送</h1><p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>通过前面我们已经了解了RocketMQ整体的架构设计，以及常见概念名词的含义，还有消息在 Broker 存储的设计。</p>
<p>今天我们把目光移到生产者这边，来看看生产者能发送哪几类消息，以及不同消息类型之间的区别。</p>
<p>根据RocketMQ 官方，关于消息的类型可以分为5大类，分别是：</p>
<ul>
<li>普通消息</li>
<li>顺序消息</li>
<li>延迟消息</li>
<li>批量消息</li>
<li>事务消息</li>
</ul>
<p>我们依次来深入了解一番。</p>
<h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>何为普通消息？</p>
<p>除去顺序、延迟、批量、事务之外的消息，就是普通消息。</p>
<p>哈哈，听起来像不像个废话，但是事实就是如此。</p>
<p>因为一开始只有普通消息，只是渐渐地需求多了，然后衍生出不同的消息类型使得它们和普通消息区分开来。</p>
<p>所以对普通消息的理解就是除去上面其他几个消息类型特性的消息，都称之为普通消息，普普通通，没啥花头。</p>
<p>所以普通消息什么好介绍的，不过介绍别的消息类型之前，我们要先了解下消息的三种发送方式。</p>
<h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p>同步消息指的是：生产者发送一条消息给Broker（代理服务器），需要等待Broker 返回响应（类似返回我收到啦），然后才会继续发送后续的消息。</p>
<p><code>producer.send（msg）</code></p>
<p>这样就保证发送的消息一定被成功接收之后，才继续处理后面的业务。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-1.png"></p>
<p>从上图来看，消息 B 的发送，需要 Broker 反馈消息 A 已经接收到了，不然生产者就会等着。</p>
<p>那假设 Broker 没反馈消息 A 咋办？因为网络是不稳定的，很有可能 Broker 反馈了，但是生产者没收到。</p>
<p>这时候生产者会进行重试。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-2.png"></p>
<p>默认会重试三次，如果三次后还是失败就会抛出异常，这时候我们需要捕获这个异常，进行日志记录或者其他兜底操作。</p>
<p>通过这个方式，我们就能保证发送成功的消息一定是被接收的了，这样一来一回其实就类似 TCP的三次握手，一次请求过去，一个 ack 回来。这个这样重试机制会导致一个弊端：<strong>消息的重复发送</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-3.png"></p>
<p>其实Broker已经存储了消息A，并且通知生产者收到消息了，但是因为网络的不稳定，生产者没收到这个响应，然后超时过后会重新发送消息A，这样一来Broker就存储了两条消息A，后面消费者消费的时候也能拿到两条消息A。</p>
<p>听起来好像无关紧要，两条就两条咯。</p>
<p>但假设消息A是银行卡扣钱的消息，那我们卡里的钱是不是可能会被扣2次了？这我们不得找客服拼命。</p>
<p>所以关于这方面我们需要做好消息的防重，或者幂等，这个后续会专门出个文章介绍。</p>
<p>这里就有个面试题何如保证消息一定发送成功？</p>
<p>答：Broker接收成功后，返回ack（类似于接收到了的响应）给生产者，没接收到ack则不认为消息发送成功，进行重试。</p>
<h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p>与同步对应的就是异步了。</p>
<p>发送异步消息的时候，生产者是不需要阻塞等待着上一条消息的返回，它可以紧接着发送后续的消息。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-4.png"></p>
<p>从图中可以看到，生产者不需要等到前面消息的响应，能直接发送后面的消息。</p>
<p>那么问题来了，假设前面的消息是发送失败，怎么办？</p>
<p>发送异步消息其实需要提供一个方法，方法里面定义了 <code>onSuccess</code>、<code>onException</code> 两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer.send（msg，<span class="keyword">new</span> <span class="title class_">SendCallback</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span>&#123;</span><br><span class="line">        <span class="comment">// do sth</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span>&#123;</span><br><span class="line">        <span class="comment">// do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>会有另外的线程来处理 Broker的响应</strong>，如果接受到成功的响应就会执行onSuccess的逻辑。</p>
<p>如果发送失败，会执行 onException 的逻辑，我们可以在这个逻辑里面实现失败的记录数据，然后进行后续的人工处理或定时处理或报警等等。</p>
<p>当然，异步消息也可以设置重试的次数，有个参数是RetryTimesWhenSendAsyncFailed，调整这个参数我们可以定义异步发送失败重试的次数。</p>
<p>它跟同步消息的区别主要在于场景的应用，同步消息需要等待前一条消息的响应才能继续发后面的消息，而异步消息不需要等待。</p>
<p>因此，在对响应时间敏感的场景下，异步消息比较合适，因为生产者不需要等待消息的响应可以直接处理后续的消息发送。</p>
<p>还有，因为异步消息也能设置重试，因此也会出现同步消息一样的消息重复问题。</p>
<h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p>前面不论是同步消息还是异步消息，我们都会关注发送完消息Broker的响应，但是有些场景压根就不关心这个结果。</p>
<p>即生产者只管发送消息，至于 Broker 有没有收到消息，生产者不关心，不需要等待响应。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-5.png"></p>
<p>比如日志的收集，日志的量级很大，但可靠性的要求不高（丟几条日志没关系），因此单向消息在这个场景就非常合适。</p>
<p>因为不需要等待响应，发完就完事，发送的耗时很短，且不需要异步线程来等待Broker，这样一来系统能同时承载更多的消息发送，性能会比较好。</p>
<p>缺点就是上面提的，不保证 Broker 一定会收到消息（会丢消息）。</p>
<p>因此适用于对消息可靠性要求不高的场景。</p>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>何为顺序消息？顾名思义按顺序发布消息，并且按发布消息的顺序来消费消息。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-6.png"></p>
<p>一个很常见的例子就是订单场景：</p>
<ol>
<li><p>创建订单</p>
</li>
<li><p>支付</p>
</li>
<li><p>发货</p>
</li>
<li><p>完结订单</p>
</li>
</ol>
<p>我们肯定需要先创建完订单，才能支付订单，且支付完才能发货，最后收到货完结订单。</p>
<p>这看起来天经地义，但是我们已经知晓消费队列的实际实现：一个Topic是分多个队列的，每个队列都有消费者并行消费。</p>
<p>假设订单相关的Topic 叫Topic-Order，那么创建订单消息发送到了队列1，紧接着客户支付了，支付消息发送到了队列2，商家立马发货，发货消息发到了队列3。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-7.png"></p>
<p>从图上来看，消息的顺序确实是有先后关系的，但是每个消费者消费的速度是不一样的，我们保证不了他们的消费速度！</p>
<p>很可能消费者-2消费了支付的消息，而消费者-1还没消费完创建订单的消息，这样一来业务顺序就错乱了，处理就报错了！</p>
<p>订单都没生成支付个啥呢？</p>
<p>所以普通消息不能保证先发送的消息一定先被消费，经过之前的分析，我们知晓本质原因就是因为多队列的实现。</p>
<p>那如何解决这个问题呢？</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-8.png"></p>
<p>把这几个消息都发送到一个队列不就完事了呗？</p>
<p>这就是顺序消息。</p>
<p>如果把创建订单、支付、发货、完结订单，这几类消息全都发往一个队列，这叫<strong>全局顺序消息</strong>。</p>
<p>如果把<strong>同一笔</strong>订单的创建、支付、发货、完结发往一个队列，<strong>不同的订单可以发往不同队列</strong>，这叫<strong>分区顺序消息</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-9.png"></p>
<p>理论上分区顺序消息够用了，并且分区顺序消息的并发度更好，从上图来看，消费者1、2能同时处理订单-1和订单2，如果是全局顺序消息，那么只有消费者-1一个人在干活。</p>
<p>然后具体将消息发送到哪个队列是生产者指定的。</p>
<p>假设要实现全局顺序消息，那么生产者将这几个消息都指定往队列1发送，即可实现全局顺序消息。</p>
<p>如果是分区顺序消息，生产者只需要依靠一个叫 <code>sharding key</code> 的东西来分区即可，比如订单的场景可以将订单号作为sharding key。</p>
<p>那么我们仅需在发送消息的时候，根据sharding key（订单号：orderld）来选择队列即可，我用伪代码来实现下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">queueIndex</span> <span class="operator">=</span> orderId % queue.size();</span><br><span class="line">producer.send(msg,queueIndex);</span><br></pre></td></tr></table></figure>

<p>这样我们就能保证一笔订单相关的消息都发往一个分区！默认普通消息是轮询选择队列，比如上一次消息发送的是队列1，后面就是队列2这样的轮询）。</p>
<p>所以在有顺序要求的场景下，我们需要采用顺序消息来实现，并且最好是分区顺序消息，这样能提高并发度，加快消息的消费速率。</p>
<h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>这也很好理解，生产者发送了消息，但是并不想立马被消费者消费，希望延迟一段时间后才能被消费。</p>
<p>比如订单取消场景，一般我们下单后，如果15分钟没有支付，这笔订单就需要被取消。</p>
<p>这个场景我们就可以在下单时候同时发送一个订单取消的延迟消息，时间是15分钟，这样15分钟后消费者就能收到这个消息，然后看看此时的订单有没有被支付，如果没有被支付，那么就执行订单取消的逻辑。</p>
<p><strong>那 RcoketMQ 中具体是如何实现延迟消息的呢？</strong></p>
<p>我们很容易想到的一个方式是将消息正常发送给 Broker，然后消费者消费的时候来判断是不是延迟消息，看看是否已经到时间了，到了就消费，没到就不消费。</p>
<p>实际上并没有这么简单，还记得我们之前文章提到的消息点位吗？消费者每消费完一条消息，需要更新消息点位来。</p>
<p>如当前消费的点位是 100，第 101 条消息消费后，点位+1，即101。</p>
<p>但延迟消息没到时间无法被消费，那不就使得正常点位卡着了，加不上去了，这样一来排在后面的正常消息不就不能被消费了？</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-10.png"></p>
<p>所以延迟消息不能这样实现，那 RocketMQ 是怎么做的呢？</p>
<p>实际上延迟消息一开始不放在正常的 Topic 中，RocketMQ 专门搞了个 Topic 叫<code>SCHEDULE_TOPIC_XXXX</code>，将所有延迟消息都放在这个Topic下。</p>
<p>然后有个定时任务来扫描遍历消息的延迟时间到了没，如果到了，那么再把延迟消息发往它本身的Topic 队列中。</p>
<p>这样就保证了延迟消息到时间之前，消费者不会消费到这个消息（因为消费者根本就没有订阅SCHEDULE_TOPIC_XXXX），然后一到时间，消息就被投递到原来的Topic上，这样消费者就能消费到了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-11.png"></p>
<p>这样的设计就复用了本身关于Topic、队列还有消费者消费消息的逻辑，是不是很巧妙？</p>
<p>对了，在RocketMQ中，延迟的时间是无法自定义的，是有固定的阶梯性限制，我们在发送消息时候，只能设定投递等级，不同等级固定对应一个延迟时间：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-12.png"></p>
<p>当然在商业版，比如阿里云上的服务是支持自定义时间的。</p>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量消息就是一次性打包发送多条消息，<strong>在对吞吐量敏感的场景，批量消息非常合适</strong>。</p>
<p>正常的消息是一条一条发，然后一条一条的等待响应。</p>
<p>而批量消息是一批一批发，比如100条消息，本来需要调用100次发送接口，且需要等待100次响应。</p>
<p>现在将这100条消息打包成1条消息发送，这样是不是仅需调用1次发送接口，且等待1次响应？</p>
<p>这样处理的效率（吞吐了）肯定是变高了。</p>
<p>当然，如果其中一条数据出错，可能需要一批重来了，处理起来也会比较麻烦。</p>
<p>关于批量消息使用起来也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Msg&gt; msgList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">msgList. add (msg1);</span><br><span class="line">msgList. add (msg2); </span><br><span class="line">msgList. add (msg3);</span><br><span class="line">producer. send (msgList) ;</span><br></pre></td></tr></table></figure>

<p>这样传入一个list，RocketMQ自然就知道这是一个批量消息了，它内部会有一个batch操作来打包这个列表：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/5-13.png"></p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>好了，最后还有一个事务消息，这个比较特殊，后面单独介绍。</p>
<p>今天这篇文章，我们需要着重掌握普通消息的三种发送方式，理解发送-响应这个模式，这样的设计能保证我们的消息不会丢失，但是带来的副作用就是可能产生重复消息。</p>
<p>然后还有顺序消息，这个不管是实际项目中，还是面试上都比较常见。</p>
<p>最后还有个批量消息，批处理思想非常关键，像Kafka底层默认会帮我们批量打包发送消息，所以Kafka 的吞吐量更大。</p>
<h2 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h2><p>比如现在我们使用了全局顺序消息，依次发送了：msg-1、msg-2、msg-3 这三条消息，假设 msg-1 被成功消费了，但是 msg-2 消费出错了，不断重试消费不断出错，这时候我们应该怎么办？</p>
<h1 id="消息队列-核心之NameSrv"><a href="#消息队列-核心之NameSrv" class="headerlink" title="消息队列-核心之NameSrv"></a>消息队列-核心之NameSrv</h1><p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-1.png"></p>
<p>从上图我们知晓看板的含义就是让生产者（producer）知晓中转站（Broker）的位置，然后消费者（consumer）也可以从看板中知晓中转站的信息，然后找到对应的中转站获取消息。</p>
<p>这个看板对应到 RocketMQ 中的角色名叫 NameSrv，即命名服务。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-2.png"></p>
<h2 id="NameSrv-与Broker"><a href="#NameSrv-与Broker" class="headerlink" title="NameSrv 与Broker"></a>NameSrv 与Broker</h2><p>在Broker启动之前，NameSrv 需要先启动。</p>
<p>待Broker启动后，Broker需要将自己的一些信息上报到NameSrv上，并且每过30s也会上报自身信息至 NameSrv。</p>
<p>NameSrv 每10s会扫描它记录的Broker 列表，看看这些 Broker 是否还活着。</p>
<p>具体判断存活的方式是看 120s 内该 Broker 是否有上报自身消息至 NameSrv，如果超过 120s 都没有，那么NameSrv会移除这个Broker相关的信息，表示这个Broker下线了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-3.png"></p>
<p>前面我们一直提到的是“相关信息”，那么具体是什么信息呢？</p>
<p>实际上就是图中画的路由信息。</p>
<p>何为路由信息？直接看源码非常直观。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-4.png"></p>
<p><strong>topicQueueTable</strong></p>
<p>这个map存储的是主题和队列的关系，之前我们提到每个topic都会分多个队列来提高并发度，不同的 topic 可以设置不同数量的队列，这个 map 存储的就是这个关系。</p>
<p>具体 QueueData 的属性如下：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-5.png"></p>
<p>可以看到里面包含了Broker的名字，以及对应的队列数量（这里分读队列数和写队列数，一般这两个队列数会设置成一样）</p>
<p><strong>brokerAddrTable</strong></p>
<p>从注释可以看到，这个map存储的是Broker名字和具体Broker相关属性的记录，也就是Broker的基础信息。</p>
<p>具体 BrokerData 的属性如下：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-6.png"></p>
<p>每个Broker都会有对应的一个brokerld，这个 broker address就是broker的地址。</p>
<p>通过这个map可以利用名字找到对应 broker地址。</p>
<p><strong>clusterAddrTable</strong> </p>
<p>Broker有集群的概念，这个map就是记录集群和对应Broker的关联关系。</p>
<p>通过集群名就能找到所有在这个集群下的Broker</p>
<p><strong>brokerLiveTable</strong> </p>
<p>Broker 地址对应的Broker 存活的相关信息，BrokerLivelnfo，即</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-7.png"></p>
<p>包括 Broker 最新上报的更新时间、版本号、读写 channel 通道等。</p>
<p>前面我提到的NameSrv每10s扫描的就是这个map。</p>
<p>然后最后一个 filterServerTable 这个我们暂时不涉及，它不在核心链路里面。</p>
<p>看到这大家对路由信息稍微有点概念就行，不需要强行记录里面的每个字段。</p>
<p>我们只需要理解：<strong>Broker 会定时的把自己关于Topic的信息上报至NameSrv，NameSrv 会维护记录这些信息，并且将无用的 Broker 剔除。</strong></p>
<h2 id="NameSrv-与Producer"><a href="#NameSrv-与Producer" class="headerlink" title="NameSrv 与Producer"></a>NameSrv 与Producer</h2><p>Broker上报这些信息给NameSrv 有什么用呢？当然是给Producer和Comsumer用的。</p>
<p>对于Producer来说，启动后它需要找到一台NameSrv进行关联，即进行长连接的建立。</p>
<p>因为Producer 需要知晓它将要发送的 Topic 应该发往哪个 Broker，具体的 Broker 的地址又是哪。</p>
<p>所以Producer需要从NameSrv获取有关Topic的路由信息，<strong>然后跟对应的Broker建立长连接，后面直接将消息发送给对应的Topic</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-8.png"></p>
<p>并且Producer每过30s会从NameSrv 获取topic和 broker最新的映射关系到本地，如果发现有新的Broker出现，那么就会跟新的Broker建立长连接。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-9.png"></p>
<p>这样一来 Producer 就可以动态的发现新 Broker 的存在，非常灵活。</p>
<p>这里需要注意一下，Producer不会缓存路由信息到本地文件中，只会放在内存里。</p>
<p>所以如果NameSrv挂了，由于Produer是直接跟Broker建立长连接直接发送消息的，所以不影响现有的消息发送。</p>
<p>但是如果这时候你将Producer 重启了，那么在 NameSrv 挂了的情况下，消息就无法正常发送了，因为路由信息都丢了，也无法从 NameSrv 获取。</p>
<p><strong>因此如果你在线上遇到类似这种情况，切忌不要随意重启 Producer，要先定位问题，盲目的重启可能产生更大的资损。</strong></p>
<h2 id="NameSrv-与-Consumer"><a href="#NameSrv-与-Consumer" class="headerlink" title="NameSrv 与 Consumer"></a>NameSrv 与 Consumer</h2><p>Consumer 和 Producer 一样，在启动的时候需要连接 NamerSrv，跟它建立长连接，并且从它获取topic 和 broker的映射关系，这样Consumer 才能知道它想要消费的消息具体在哪个 Broker。</p>
<p>然后会跟有关系的 Broker 建立长连接，这个和 Producer 是一样的，<strong>发送消息的过程和消费消息的过程是不会经过 NamerSrv 这个中间商的</strong>。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-10.png"></p>
<p>生产者和消费者会直接跟 Broker 进行交互的，NameSrv 的作用就是“看板”，来记录维护路由信息，给Consumer和Producer 指路。</p>
<h2 id="NameSrv-与NameSrv"><a href="#NameSrv-与NameSrv" class="headerlink" title="NameSrv 与NameSrv"></a>NameSrv 与NameSrv</h2><p>我们已经知晓了NameSrv 的重要性，那如果 NameSrv 挂了咋办？</p>
<p>新接入的Producer和 Consumer 就成为瞎子了，一个不知道将消息发往哪，一个不知道从哪里获取消息。</p>
<p>这样业务就会受到阻碍。</p>
<p>为了避免单点故障，在生产环境我们需要部署多台 NameSrv 形成 NameSrv 集群，这样一来假设发生了意外，一个 NameSrv 挂了，那么别的 NameSrv 可以顶上。</p>
<p>既然有多台NameSrv，那么 Broker 启动的时候随便选一台上报自己的路由信息就行了吗？</p>
<p>不是的。</p>
<p><strong>RocketMQ实现的NameSrv非常轻量级，集群内的NameSrv是互相独立的存在，它们之间不会进行任何的信息交互。</strong></p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-11.png"></p>
<p>因此Broker 需要给集群内的每一台 NameSrv 都上报路由信息，这样每台 NameSrv 存储的都是完整的路由信息。</p>
<p>这样的设计使得NameSrv的实现非常简单，不涉及集群内多台NameSrv 的数据交互，就没有类似脑裂等信息不一致的问题。</p>
<p>而对Producer 和 Consumer 来说，因为多台NameSrv 的数据都是一样的，因此它们只需要随机选择集群内的一台 NameSrv 进行长连接即可获取全量的路由信息。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>NameSrv 这个角色就是动态路由中心，会维护存活的 Broker 信息，记录 Topic 的路由关系，使得Producer和Consumer可以正确的找到对应的 Broker。</p>
<p>RocketMQ简单的自己设计了一个轻量级路由中心而不是依赖于其他三方组件，这样对整个消息队列中间件而言更轻量和自主。</p>
<p>我看了下源码，NameSrv的实现一共也就2800多行代码，而且其中还统计了单测的代码行。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/6-12.png"></p>
<p>在 kafka 中，对应 NameSrv 角色的是 zookeeper，但是 zk 的实现会比较重，比如用了 zab 的算法，需要同步数据，保证强一致性等等。</p>
<p>zk 集群中多台机器会进行数据同步，就会产生数据一致性问题，NameSrv 则直接每台都存储全量的数据，且之间不进行任何信息交互，完美地避开数据不一致的问题。</p>
<p>kafka在新版本中已经移除了zk的强依赖（强一致性在性能方面开销会比较大）。这也告知我们，技术并不是越复杂、听起来越高级越好，<strong>只要合适的，简单就是最好的</strong>。</p>
<h2 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h2><p>Broker，Producer，Consumer是如何知晓NameSrv的地址的？</p>
<p>解答：</p>
<p>在 Apache RocketMQ 中，Broker、Producer 和 Consumer 是如何知晓 NameServer 的地址的。以下是它们的行为：</p>
<ol>
<li><p>Broker：在启动时，Broker 会通过配置文件指定 NameServer 的地址。Broker 会定期向 NameServer 注册自己的信息，包括主题（Topic）和队列（Queue）的信息。这样，Producer 和 Consumer 就可以通过 NameServer 获取 Broker 的地址信息。</p>
</li>
<li><p>Producer：在发送消息之前，Producer 首先需要获取目标主题的路由信息，包括可用的 Broker 地址。Producer 通过与 NameServer 通信，请求目标主题的路由信息。NameServer 根据自身维护的元数据，返回 Producer 所需的路由信息，其中包含可用的 Broker 地址。Producer 使用这些地址来发送消息。</p>
</li>
<li><p>Consumer：在启动时，Consumer 也会通过配置文件指定 NameServer 的地址。Consumer 在订阅特定主题时，需要获取该主题的路由信息，包括可用的 Broker 地址。Consumer 会向 NameServer 请求目标主题的路由信息，然后根据返回的路由信息建立与 Broker 的连接，从中接收消息。</p>
</li>
</ol>
<p>总而言之，NameServer 在 RocketMQ 中充当了一个路由和配置中心的角色。Broker 在启动时注册自己的信息到 NameServer，Producer 和 Consumer 通过与 NameServer 通信获取所需的路由信息，以便能够与正确的 Broker 建立连接和发送&#x2F;接收消息。这种设计使得 RocketMQ 的拓扑结构可以相对灵活地进行扩展和配置。</p>
<h1 id="消息队列-核心之消息的消费（1）"><a href="#消息队列-核心之消息的消费（1）" class="headerlink" title="消息队列-核心之消息的消费（1）"></a>消息队列-核心之消息的消费（1）</h1><p>RocketMQ整体设计架构：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>前面我们已经了解了消息是如何存储、发送以及命名中心的作用，接下来我们就要学习下消息是如何被消费者消费的。</p>
<p>不过，在这之前我们需要先想明白一个问题：消息存储在 Broker，那么到底是消费者去 Broker 讨要消息，还是Broker将消息送到消费者手上？</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/7-1.png"></p>
<p>这个问题也是一个常见的面试题，即消息是推给消费者的（push），还是消费者去拉的（pull）？</p>
<h2 id="消息对比快递"><a href="#消息对比快递" class="headerlink" title="消息对比快递"></a>消息对比快递</h2><p>消息的消费或者说接收其实跟收快递是一个道理。</p>
<p>快递的接收现在一般有两种模式：</p>
<ol>
<li>快递员送货上门</li>
<li>我们去驿站（丰巢柜）拿快递</li>
</ol>
<p>第一种很舒服，送货上门，但是假设我们不在家，在外忙着打工，也没时间赶回家，这时候就不好办了（当然现实中是有快递员会把快递直接放门口，但是被人偷了咋办？）</p>
<p>第二种需要我们花点力气，对比送货上门我们得跑一趟去拿快递，但是好处就是我们可以自己安排时间去拿，比如晚上下班回家空了，我们就去驿站（丰巢柜）拿快递，如果最近几天很忙，一直加班，那我们可以过两天再去拿。</p>
<p>这两种模式对应的就是消息的推和拉。</p>
<p>快递员送货上门对应 Broker 将消息推送给消费者。</p>
<p>我们去驿站（丰巢柜）拿快递对应消费者主动去 Broker 拉消息。</p>
<p>到底哪种模式比较好呢？</p>
<p>主要还是看场景，<strong>在编程中，没有最好的，只有合适的</strong>。</p>
<h2 id="推消息"><a href="#推消息" class="headerlink" title="推消息"></a>推消息</h2><p>推消息指的是 Broker 收到对应的消息，立马将消息推送给消费者。</p>
<p><strong>这种方式的优点是：</strong></p>
<p><strong>消息的实时性非常高</strong>，并且对消费者而言实现比较简单，啥都不用干直接等着消息上门就行。</p>
<p><strong>缺点也明显：</strong></p>
<p>消费者在某个时段可能非常忙，没有时间来处理新的消息，而Broker 还傻傻地使劲推消息过来，消费者 CPU 都快干烧了，还使劲派活，可能会直接把消费者干爆了。</p>
<p>这就违背了消息队列的一个初衷：削峰填谷。</p>
<p>消息队列本身的作用是想如果消息处理不过来先在 Broker 存着，这叫削峰，等空了再让消费者处理消息，这叫填谷，现在一个劲的推消息给消费者，这跟有没消息队列还有啥区别？</p>
<p>看到这个有人就想，那简单啊，Broker先看看消费者的处理速度，如果处理的很快就给多点，处理慢了就推慢点。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/7-2.png"></p>
<p>理论上是可行的，Broker反正会先持久化存储消息，不怕消息丢了，然后在推送消息给消费者之前，先打探下消费者的情况，就好比快递师傅送货上门前会先打电话问问你在不在。</p>
<p>如果消费者ok 的，那么就推送消息，如果不 ok，那就再等等。</p>
<p>但是消费者可能很多，每个消费者的消费速率又不一致，Broker如果需要照顾维护到这么多消费者的情况，对Broker的自身而言实现上会增加复杂度，对Broker的性能也会产生影响。</p>
<p>你想想看，如果快递非常多，快递师傅需要一个一个打电话确认是否在家，快递师傅是不是会比较累？</p>
<p>效率也会降低。</p>
<p>所以<strong>推模式适用在消费者不多、消息量不大、及时性要求高的场景</strong>。</p>
<h2 id="拉消息"><a href="#拉消息" class="headerlink" title="拉消息"></a>拉消息</h2><p>拉消息指的是消费者主动去 Broker 拉取对应的消息。</p>
<p><strong>这种方式的优点是：</strong></p>
<p>Broker轻松了，生产者发送消息给Broker后，Broker仅需存储好消息就行了，接下来就等着消费者来拉消息，不需要维护其他关系。<br>主动权掌握在消费者手上，每个消费者可以根据自身当时的情况，选择合适的时机去Broker拉取消费。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/7-3.png"></p>
<p>比如，现在空了，那就去 Broker 拉消息来消费，如果现在很忙，那就等过了这段时间再去拉。</p>
<p>而且消费者还可以根据自身情况选择一次性拉取消息的数量，比如消费者1比较猛，那一次性拉50条，消费者2比较弱，那一次性拉 10 条。</p>
<p>在推消息的场景，Broker 可以来一条就推一条给消费者，也可以缓存一定数量的消息再推，但是就像我们说的，每个消费者的情况不一样，所以推模式具体缓存多少数量消息再推很难有个定数。</p>
<p>这叫众口难调，所以每个消费者自己根据自己情况去拉取比较合适。</p>
<p><strong>缺点也明显：</strong></p>
<p><strong>消息的消费可能不及时</strong>。因为如果需要消费者主动去Broker拉取消息，那么在代码上的实现就是消费者定时去 Broker 拉取（如果一直有消息那就是拉过来消费完了立马去拉取）。</p>
<p>假设定时1分钟去拉一次，发现没任何消息，而恰巧最新的一条消息刚好在消费者拉取请求后存储到 Broker。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/7-4.png"></p>
<p>那么即使现在的消费者是闲着，刚到的消息也必须等一分钟后的定时拉取才会被消费，这就是消费的不及时。</p>
<p>看到这有人可能会说，那把定时时间调短一点，比如 1s就去拉一次，这样不就解决这个问题了吗？</p>
<p>确实是，如果定时拉取的时间改短一些，消费不及时的现象可以得到缓解，但是同时也带来了另一个问题：消息忙请求。</p>
<p>忙请求很好理解，比如我们设置每1s去拉取消息，那么即使当前几个小时内都没消息投递过来，我们也需要持续性去请求Broker，尝试去拉取消息，这就是忙请求。这么听下来，好像推也不好、拉也不好，那到底该如何让消费者获取消息呢？</p>
<h2 id="推还是拉？"><a href="#推还是拉？" class="headerlink" title="推还是拉？"></a>推还是拉？</h2><p>就像我前面说的，没有最好的，只有最合适的。</p>
<p>其实业界生产级消息队列的实现有用推的也有用拉的。</p>
<p>ActiveMQ 用的就是推模式，而 RocketMQ 和 Kafka 用的就是拉模式。</p>
<p>ActiveMQ 就不说了，现在基本上没啥人用了，算是上一个时代的产物。</p>
<p>但是 RocketMQ 和 Kafka 正值壮年，它们不在乎拉模式的缺点吗？</p>
<p>实际上它们没有使用“朴素”的拉模式，而是采取了一种“变种”拉模式：<strong>长轮询</strong>。</p>
<p>听起来好像挺高级，但是实际上就是玩了一个小技巧：</p>
<p>消费者发送拉取请求到 Broker 时，如果此时有消息，那么 Broker 直接响应返回消息，如果没消息就 hold 住这个请求，比如等 15s，在 15s 内如果有消息过来就立马响应这个请求返回消息。</p>
<p>如果没有消息过来就返回无消息。</p>
<p>这样一来<strong>既避免了忙请求的情况，也进一步的提升了消息的及时性</strong>，可谓一举多得！是不是非常的巧妙？</p>
<p>RocketMQ 和 Kafka 都是采取这样的方式来实现消息的获取。</p>
<h2 id="RocketMQ的push和pull"><a href="#RocketMQ的push和pull" class="headerlink" title="RocketMQ的push和pull"></a>RocketMQ的push和pull</h2><p>有些小伙伴可能用过 RocketMQ，说不对呀，RocketMQ 既有 pushConsumer 也有pullConsumer，所以推和拉两个模式它都实现了。</p>
<p>实际上不是的，<strong>RocketMQ 本质上只实现了拉模式，pullConsumer 就是去拉消息很好理解，至于还有个 pushConsumer 实际上是伪推模式，底层的实现还是基于长链接的长轮询去拉取消息</strong>。</p>
<p>pushConsumer的实现是背后有个线程会一直从Broker拉取消息，如果当前有过多的消息未被消费，那就过一会儿再执行，一旦有消息返回就回调用户定义的MessageListener 来消费消息。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>好了，今天我们主要介绍了消费消息的推、拉两个模式。</p>
<p>这个也是我之前去大厂面试被问到的一个面试真题，当然最重要的还是这个长轮询模式技巧，需要大家细细品味，还是很巧妙的。</p>
<p>然后关于推、拉两个模式的优缺点也是需要大家掌握的，其实本质上这两个模式对应很多编程上的场景，我们需要做到的是明确这些处理方式的优劣，然后在合适的场景选择合适的手段去处理这些问题。</p>
<p>这就是技术选型，当我们达到一定的技术沉淀后，掌握这个技巧，在面临架构的抉择时，列出不同架构的优势和劣势，最终根据当下和未来的趋势选择此时最优的架构。</p>
<h2 id="思考-5"><a href="#思考-5" class="headerlink" title="思考"></a>思考</h2><p>RocketMQ还有个DefaultLitePullConsumer，能说说它跟DefaultMQPullConsumer有什么区别吗？</p>
<p><strong>解答</strong>：</p>
<p>在 RocketMQ 中，DefaultLitePullConsumer 和 DefaultMQPullConsumer 是两种不同的消息拉取消费者客户端。它们之间有以下区别：</p>
<ol>
<li><p>功能复杂性：DefaultMQPullConsumer 是完整的消息拉取消费者客户端，支持较多的高级特性，如消息过滤、顺序消费等。它提供了更多的功能和灵活性，适用于复杂的消费场景。</p>
<p>DefaultLitePullConsumer 是轻量级的消息拉取消费者客户端，它是为了简化消费者客户端的使用而设计的。相比于 DefaultMQPullConsumer，DefaultLitePullConsumer 剥离了一些高级特性和配置选项，使得使用起来更加简单和便捷。</p>
</li>
<li><p>依赖库大小：DefaultMQPullConsumer 依赖的客户端库较大，因为它包含了完整的功能和特性。这意味着在应用程序中引入 DefaultMQPullConsumer 会增加额外的依赖库的大小。</p>
<p>DefaultLitePullConsumer 是一个精简的客户端库，其依赖库更小，可以减少应用程序的大小和资源占用。</p>
</li>
<li><p>部署和配置：DefaultMQPullConsumer 在使用时需要进行一些复杂的配置，例如指定 NameServer 的地址、消费者组名、订阅主题等。这些配置项需要根据具体的业务需求进行调整和设置。</p>
<p>DefaultLitePullConsumer 的配置相对简单，通常只需要指定 NameServer 的地址和订阅主题即可。这样可以降低配置和部署的复杂性，使得使用起来更加方便。</p>
</li>
</ol>
<p>总结起来，<strong>DefaultMQPullConsumer 提供了更多的功能和配置选项，适用于复杂的消费场景，但引入的依赖较大。而 DefaultLitePullConsumer 是一个轻量级的消费者客户端，简化了配置和部署，适用于简单的消费场景，尤其适合移动端和资源有限的环境。</strong>选择使用哪个消费者客户端应根据具体的需求和使用场景进行决策。</p>
<h1 id="消息队列-核心之消息的消费（2）"><a href="#消息队列-核心之消息的消费（2）" class="headerlink" title="消息队列-核心之消息的消费（2）"></a>消息队列-核心之消息的消费（2）</h1><p>RocketMQ整体设计架构：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<p>上篇我们已经了解了主流消息队列的消费模式：让消费者主动去Broker拉取消息来消费。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-1.png"></p>
<p>并且都是基于<strong>长轮询</strong>的实现来避免频繁请求和提高消息的及时性。</p>
<p>这篇我们深入了解下消费者消费消息的一些细节。</p>
<h2 id="消费者启动"><a href="#消费者启动" class="headerlink" title="消费者启动"></a>消费者启动</h2><p>消费者启动的时候，需要去找看板（namerSrv），因为它还不知道它订阅的 Topic的消息要从哪获取。</p>
<p>于是乎启动时候需要指定 namerSrv 的地址，紧接着它根据自己的订阅情况从 namerSrv 获取对应Topic 的路由信息。</p>
<p>这时候它就知晓自己想要的Topic在哪个Broker，以及Broker对应的地址。</p>
<p>这样消费者就跟 Broker 搭上线了，连上了 Broker 后，Broker 也知晓了这个消费者的存在。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-2.png"></p>
<p>紧接着就要做一件很重要的事情：“<strong>分赃</strong>”，并且是合理的“分赃”。</p>
<p>我们已经知道 Topic 下还有队列的概念：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-3.png"></p>
<p>消费者实际是去Topic 下的某个队列获取消息，假设 Topic 有4 个队列，此时消费组 A 只有一个消费者，那么毋庸置疑，这个消费者需要消费这 4 个队列的消息。</p>
<p>那么假设消费组A新来了一个消费者，那么此时就需要将这个4个队列分2个给新来的消费者，这样减轻了老消费者的压力，也提高了消费的效率，这就是我所谓的“分赃”：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-4.png"></p>
<p>“分赃”的契机就是新消费者启动连上Broker时，此时 Broker 知晓有新的消费者来了，于是乎告诉之前的消费者开始“分赃”了，当然这个新消费者不需要Broker的通知自己就会开始“分赃”。</p>
<p>所谓的“分赃”具体过程也简单：<strong>由消费者遵循一定的规则主动来分</strong>的。</p>
<p>消费者收到要“分赃”的通知后，获取这个Topic下的所有队列，比如队列-1、队列-2、队列-3、队列-4，紧接着获取订阅这个Topic的消费组下的消费者信息，比如消费者-1、消费者-2。</p>
<p>然后排个序：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-6.png"></p>
<p>排好序后，就平分呗：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-7.png"></p>
<p>这样一来，新的消费者一上线，就可以立马进行“分赃”，马上投入消费的工作中为整体的消费减压，这个“分赃”的专业名字叫：<strong>重平衡</strong>，也是<strong>客户端的负载均衡</strong></p>
<p>如果这个消费组同时再来两个消费者，那么重平衡过后，就是每个消费者负责一个队列：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-9.png"></p>
<p>如果此时再来一个消费者呢？重平衡过后，新来的消费者还是空闲的。</p>
<p>原因是每个队列都已经有负责的消费者了，没有更多的队列给新来的消费者了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-10.png"></p>
<blockquote>
<p>这就涉及到一个面试题：消息堆积时，增加消费者有用吗？</p>
</blockquote>
<p>这下我们知道答案了，<strong>不一定</strong>。</p>
<p>如果这个消费组的消费者数量比Topic的队列数量小，此时增加消费者可以缓解消息堆积。</p>
<p>如果消费者数量比队列数还多，则没用。</p>
<p>当然了，不仅仅是在消费者启动的时候会触发重平衡，每个消费者也会有个定时任务，每20 s 主动重平衡下，也就是负载均衡了，防止消费任务不均衡。</p>
<p>并且，如果有消费者下线了，由于消费者和Broker建立了连接，下线后Broker可以知晓这个情况，此时Broker也会通知所有消费者进行重平衡。</p>
<p>还是拿队列-1、队列-2、队列-3、队列-4、消费者-1、消费者-2 来举例：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-11.png"></p>
<p>此时消费者-1下线了，那么消费者-2需要承担起所有队列。</p>
<p>被 Broker 通知重平衡后，消费者-2同时消费队列-1、队列-2、队列-3、队列-4：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-12.png"></p>
<p>这样一来就实现了动态的负载均衡功能，可以灵活的操作消费者上下线。</p>
<p>在业务高峰的时候，增加消费者，在业务低峰时候减少消费者。</p>
<h2 id="如何拉消息"><a href="#如何拉消息" class="headerlink" title="如何拉消息"></a>如何拉消息</h2><p>重平衡后，每个消费者都知晓它所负责的是Topic下的哪个队列，下面的任务只要去Broker拉取对应队列的消息就行了。</p>
<p>那具体如何拉呢？</p>
<p>最简单的想法肯定是一个队列对应一个线程，然后由每个线程负责去拉取对应的消息，但是队列可能很多，与之对应的线程也会很多，线程多了并不是好事，因为上下文切换频繁会带来损耗。</p>
<p>并且由于重平衡的机制，对应的队列数量也是变化的，队列变化后，对应的线程也要变，那不还得管理线程的生命周期？</p>
<p>都到这份上了，直接上线程池呗。</p>
<p>实际上不用这么麻烦。</p>
<p><strong>RocketMQ只用了一个线程（叫PullMessageService）来执行拉消息的操作，所有的拉取消息的动作都会被封装成 pullRequest，扔到 pullRequestQueue 这个阻塞队列里面。</strong></p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-13.png"></p>
<p><strong>然后 PullMessageService 会不断的从 pullRequestQueue 拉取 pullRequest，根据 pullRequest 里面的内容构建请求去对应的 Broker 拉取消息。</strong></p>
<p>pullRequest 里面包含了消费组的信息、消费点位、Topic、队列id等。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-14.png"></p>
<p><strong>当上一个 pullRequest 拉取得到结果后，里面会根据响应构建新的 pullRequest 塞入到pullRequestQueue里面，以此来达到消息的不间断拉取。</strong></p>
<p>这里还需要引入一个叫ProcessQueue的概念。</p>
<p>根据 pullRequest 获取到的结果会先缓存到 ProcessQueue 里面，并且再构建一个消费任务（consumerRequest）给ConsumeMessageService这个线程池来消费消息。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-15.png"></p>
<p><strong>ProcessQueue起到了暂缓消息的作用</strong>，即从Broker拉到了消息，但是还未被消费者消费，这个数据可以用来<strong>流控</strong>。</p>
<p>如果暂缓的消息很多，那说明消息处理的慢，消息在消费者这里有堆积的情况，这时候就需要限制一下拉取的速度。</p>
<p>也就是说不能一直构建 pullRequest了，要等等，这就起到了流控的作用。</p>
<p>可以看到这样的实现机制，仅仅通过控制 pullRequest 的生成就能达到流控的目的，是不是很简单！</p>
<h2 id="消息点位（offset）"><a href="#消息点位（offset）" class="headerlink" title="消息点位（offset）"></a>消息点位（offset）</h2><p>之前的文章我们提到，每个消费组需要维护 Topic 下的每个队列被消费的点位，那这个点位是怎么保存的？在什么时候提交的呢？在不同模式下，保存的方式不同。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p><strong>在广播模式下，消费点位将存储在消费者本地磁盘上</strong>，因为广播模式是将消息广播给每个消费者，它不需要有个统一的地方来管理这个位置，每个消费者自己维护就行。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>而集群模式就不能本地维护了。</p>
<p>因为集群模式下，同个消费组内的消费者是互帮互助的关系，如果某个消费者下线了，需要另一个消费者顶上了，这时候另一个消费者需要知晓之前消费者的消费进度，不然总不能从第一条消息开始消费吧。</p>
<p>所以<strong>集群模式下，消费点位是存储在 Broker 的</strong>，这样顶上的消费者可以从 Broker 获取消费点位。</p>
<p>那消费者具体是在什么时候将自己的消费位置告知给 Broker 更新的呢？</p>
<p><strong>在拉取消息的时候</strong>。</p>
<p>拉取消息的时候会顺带把此时的消费点位提交给 Broker，这样 Broker 就能得知最新的消息进度了。</p>
<p>看到这里可能有同学会产生疑惑：<strong>拉消息的时候才去提交，那假设消费完了，还没来得及去拉消息，消费者就挂了，那么此时的存在 Broker 里的消费点位不就不准了吗</strong>？</p>
<p>是的，确实不准，此时如果发生了重平衡，队列更换了新的消费者，那么就会导致消息的重复消费！</p>
<p>因此，这个设计无法保证消息只会被消费一次，因此我们能做的就是做好消费者端的<strong>幂等</strong>，使得消费多次消息跟消息一次消息达到的效果是一样的。</p>
<p>目前没有更好的解决方式。</p>
<h2 id="如何消费消息"><a href="#如何消费消息" class="headerlink" title="如何消费消息"></a>如何消费消息</h2><p>上文已经提到，拉取到消息后会构建 ConsumeRequest 提交到线程池ConsumeMessageService。</p>
<p>这个线程池有两个实现，一个是并发消费，一个是顺序消费，一般情况下我们都是使用并发消费。</p>
<p>线程池正常消费的过程很普通，没什么需要特别关注的，但是假设消息消费失败了怎么办？</p>
<p>我们能想到的方式是重试，但是重试多次还是失败呢？如果一直消费这条消息不就会堵塞住后面的消息了？</p>
<p>所以RocketMQ的实现是将消息失败的消息，返回发送给Broker，这个消息会被发送到特定的一个重试Topic：”%RETRY%+consumerGroup”。</p>
<p>这样一来，消费失败的消息不会阻塞原先Topic上的其他消息，而是在重试队列上等待后续的重试消费。</p>
<p>当然如果重试多次还是一直消费失败的话，会把这个消息打入到死信队列中，这时候就需要人工介入去处理这些消息了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/8-17.png"></p>
<p>RocketMQ 默认16 重试失败后，打入死信队列。</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>好了，整体关于消费者消费消息的介绍就差不多了，消费的过程会比生产的过程复杂一些，还是需要大家结合上下文多捋捋。</p>
<p>其实还有很多细节没有介绍，但是不建议刚开始学习就深入到这些细节中，我们以理解核心脉络为主，后面才开枝散叶。</p>
<h2 id="思考-6"><a href="#思考-6" class="headerlink" title="思考"></a>思考</h2><p>上面我们提到拉消息的限流操作，限流主要是因为消息处理不过来，那么具体是怕消费者的内存溢出，还是怕 CPU 爆了呢？</p>
<p><strong>解答：</strong></p>
<p>限流操作主要是为了避免消费者无法处理过多的消息而导致系统资源耗尽，包括内存和 CPU。具体来说，限流操作可以应对以下两种情况：</p>
<ol>
<li><p>内存溢出：如果消费者无法及时处理大量的消息，消息队列可能会持续将消息推送给消费者，从而导致消费者内存的持续增长。当消费者的内存资源耗尽时，可能会导致内存溢出的问题。</p>
<p>通过限流操作，可以控制消费者同时处理的消息数量，使其保持在可处理范围内。消费者可以逐条或者批量拉取消息，然后逐条或者批量进行处理，确保消费者的内存占用在可接受的范围内。</p>
</li>
<li><p>CPU 负载过高：消费者处理大量消息时，消费逻辑的复杂性或者处理时间过长可能导致 CPU 负载过高。如果消费者的 CPU 资源被耗尽，可能会导致消费者响应变慢、延迟增加或者系统负载过高。</p>
<p>通过限流操作，可以控制消费者的消费速率，避免过多的消息堆积导致 CPU 负载过高。消费者可以根据自身的处理能力和负载情况，适当地控制消息拉取的速率，确保 CPU 资源能够有效地处理消息。</p>
</li>
</ol>
<p>限流操作可以通过以下方式实现：</p>
<ul>
<li>控制消费者每次拉取的消息数量，避免一次性拉取过多消息。</li>
<li>设置消费者的并发消费线程数，限制消费者同时处理的消息数量。</li>
<li>根据消费者的处理能力动态调整拉取消息的频率，确保消费者的负载适中。</li>
</ul>
<p>通过合理的限流策略，可以在消费者和消息队列之间实现资源的平衡，避免消费者过载而导致的系统问题。具体的限流策略需要根据实际场景和系统资源进行调优和测试。</p>
<h1 id="消息队列-阶段总结篇"><a href="#消息队列-阶段总结篇" class="headerlink" title="消息队列-阶段总结篇"></a>消息队列-阶段总结篇</h1><p>通过前面几篇文章，我们已经了解了RocketMQ 相关的专业名词，比如生产组、消费组、Topic等，以及消息的发送过程、存储过程、消费过程。</p>
<p>现在我们需要把这些知识整合起来，在脑海中形成一个有关消息队列的脑图。</p>
<p>这篇文章我就来带着大家串联起这些知识，首先我们还是需要总览一下整个RocketMQ 架构体系：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1-1.png"></p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>nameSrv它会保存 Topic 与 Broker 的关联信息，Broker 会将自己的信息上报给 nameSrv。</p>
<p>生产者从 nameSrv 获得它要发送的 Topic 对应的 Broker 信息。</p>
<p>消费者从 nameSrv 获取它要消费的Topic 对应的 Broker信息。</p>
<p>nameSrv 虽然有集群的概念，但是集群内的 nameSrv 互不通信，它们都是<strong>独立的存在</strong>。</p>
<p>生产者会随机跟一个 nameSrv 建连交互，每 30s 从 nameSrv 拉取最新的 Topic 相关数据。消费者会随机跟一个 nameSrv 建连交互，每 30s 从 nameSrv 拉取最新的 Topic 相关数据。</p>
<p>Broker 需要跟集群里面的所有 nameSrv 建连交互，每 30s 上报自身信息给 nameSrv。</p>
<p>nameSrv 会维护 Broker 的信息，如果 Broker 下线了，会移除对应的 Broker 信息，这样生产者和消费者拉取 Topic 相关信息时就能感知到 Broker 的下线。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-1.png"></p>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>Broker 启动之后会跟 nameSrv 集群里面的<strong>每一台</strong> nameSrv 建连，并且定时上报自己的信息给nameSrv，包含自己的IP信息、Topic信息等。</p>
<p>Broker存储Topic消息，而Topic会分多个队列，如果有Broker集群，那么一个Topic的多个队列会分散在一个 Broker 集群的不同 Broker 中。</p>
<p>比如 TopicA 有4 个队列，那么此时 Broker 集群里，BrokerA 存 1、2两个队列，BrokerB 存 3、4两个队列。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-2.png"></p>
<p>Broker 会将不同的 Topic 消息都写入到同一个文件，即 commitlog 里，所有的消息追加写入到一个文件，这叫<strong>顺序写</strong>，根据磁盘的物理结构，顺序写的效率很高。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-3.png"></p>
<p>Broker 会有一个后台线程，一直将新加入的 commitlog 里面的消息，映射到 consumerQueue中：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-4.png"></p>
<p>consumerQueue对应的就是Topic队列的概念，消费者直接消费的对象也是consumerQueue。</p>
<p>consumerQueue里面存储的是消息在commitlog里面的起始物理地址、长度、taghash。</p>
<p>消费者消费的时候先找到对应的 consumerQueue，再根据 consumerQueue 里面的数据，找到commitlog 得到对应的消息内容。</p>
<p>除了 commitlog 和 consumerQueue，broker 还有个 IndexFile，即消息的索引文件。</p>
<p>我们在发送消息时，可以给消息设置索引，这样方便我们通过 key 直接查询对应的消息：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-5.png"></p>
<p>IndexFile 的设计也非常的巧妙，需要我们细细品味。</p>
<h2 id="producer（生产者）"><a href="#producer（生产者）" class="headerlink" title="producer（生产者）"></a>producer（生产者）</h2><p>producer 启动之后就会选择一台 nameSrv 进行建连，从 nameSrv 拉取自己想要发送的 Topic 对应的 Broker 信息。</p>
<p>紧接着跟 Broker 建立连接，后续发送消息直接跟 Broker 进行交互。</p>
<hr>
<p>根据 RocketMQ 官方，关于消息的类型可以分为 5 大类，分别是：</p>
<p><strong>普通消息</strong></p>
<p>没啥花头，就是普通消息。</p>
<p><strong>顺序消息</strong></p>
<p>顺序消息指按顺序发布消息，并且按发布消息的顺序来消费消息。</p>
<p>就好比：生成订单后，才能支付，支付完成，才能发货，发了货，用户才能收货，这就是顺序。</p>
<p>顺序消息又分为<strong>全局顺序</strong>和<strong>局部顺序</strong>，拿订单的一套流程举例：</p>
<ul>
<li>全局顺序：现有订单1、2、3，订单1处理完了，才能处理订单2，订单2处理完了，才能处理订单3</li>
<li>局部顺序：现有订单1、2、3，由于是不同订单，1、2、3可以并行处理，但是同一笔订单之间的下单、支付、发货等都是顺序的。</li>
</ul>
<p><strong>延迟消息</strong></p>
<p>producer 发送了消息，但是不想立马被消费者消费，想等到一定时间后再被消费者消费。</p>
<p>一个场景就是订单取消的场景，15分钟后如果订单还未被支付，则订单被自动取消。</p>
<p>这时候实现方式可以在下单时，让生产者立马发送一条取消订单的延迟消息，延迟时间是 15 分钟。</p>
<p><strong>批量消息</strong></p>
<p>正常的消息是一条一条发，然后一条一条的等待响应。</p>
<p>这样一来一回在正常情况是没问题的，但是在大批量消息持续发送的情况下，这种一条一条一来一回的效率就比较低。</p>
<p>所以有个批量消息，它可以将一批消息打包成一条消息发送，这样能大幅度减少网络上一来一回的开销，提高消息发送的吞吐量。</p>
<p><strong>事务消息</strong></p>
<p>事务消息后面会专门写一篇文章介绍实现原理，这里简单提一下。</p>
<p>事务消息就是将执行本地事务跟发送消息结合在一起，使得本地事务的执行和发送消息在一个事务内，即本地事务执行成功那么发送的消息可以被消费者消费到。</p>
<p>如果本地事务执行失败，则发送的事务消息不会被消费者消费到，这样就能保证业务上的一致性。</p>
<hr>
<p>紧接着就是发送消息的三种方式：</p>
<p><strong>同步发送</strong></p>
<p>同步发送消息指的是producer发送消息后，需要同步等待Broker的响应后，才能继续进行后面业务逻辑的执行。</p>
<p>大部分业务场景都是使用同步发送，处理简单，可靠。</p>
<p><strong>异步发送</strong></p>
<p>异步发送消息指的是 producer 发送消息后，无需同步等待 Broker 的响应，仅需设置一个回调来处理 Broker的响应，可以立马进行后面业务逻辑的执行。</p>
<p>适用于业务响应时间敏感的场景，即没有时间同步等待消息的响应，需要异步化提高业务处理速度。</p>
<p><strong>单向发送</strong></p>
<p>同步和异步操作都会处理 Broker 的响应，如果 Broker 响应失败则还需进行消息的重试发送。</p>
<p>而单向发送则不等待 Broker 的响应，也没有回调函数，即只发送消息不等待响应，也不关心响应。</p>
<p>所以相对同步和异步，单向发送更轻量级，适用于可靠性要求不高的场景，比如日志的收集。</p>
<h2 id="consumer（消费者）"><a href="#consumer（消费者）" class="headerlink" title="consumer（消费者）"></a>consumer（消费者）</h2><p>consumer 启动之后就会选择一台 nameSrv 进行建连，从 nameSrv 拉取自己想要消费的 Topic 对应的 Broker 信息。</p>
<p>紧接着跟 Broker 建立连接，后续消费消息直接跟 Broker 进行交互。</p>
<hr>
<p>关于消费者如何从 Broker 获取消息有两种方式：</p>
<ul>
<li>Broker 推给 consumer </li>
<li>consumer 主动从去 Broker 拉</li>
</ul>
<p>现在主流的消息队列都是<strong>采取拉的方式来实现消息的获取</strong>，因为推消息不容易把控消费者的消费情况，如果消费不过来还使劲推容易导致消费者挂了。</p>
<p>当然朴素的拉消息也有问题，比如拉取的不及时，或者忙拉取的情况，因此拉消息的时候都是基于<strong>长轮询拉取</strong>，即消费者向 Broker 发送拉取请求，如果当前有消息则立马返回，如果没有消息那么broker 会先 hold 住这个请求。</p>
<p>然后等着，如果此时有生产者发送消息过来，则立马响应这些消息给消费者。</p>
<p>如果没有消息则等待一定时间后返回消费者无消息的响应，然后消费者立马再次请求，如果往复循环。</p>
<p>对了，RocketMQ虽然对应的消费者实现类有pullConsumer、pushConsumer，但是底层都是用的都是拉模式，无非是封装的看着像推的罢了。</p>
<hr>
<p>consumer还有<strong>重平衡</strong>的操作来实现消费的负载均衡，consumer 消费某个Topic的消息，实际是去Topic下的某个队列去拉取消息。</p>
<p>而一个 Topic 往往会有多个队列，也同时会有一个消费组一起来消费这个 Topic 的消息，一个消费组往往由多个消费者组成。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-6.png"></p>
<p>消费组里面的消费者们会瓜分消费Topic的队列们，正常情况下瓜分结束后不需要有什么变动。</p>
<p>但是如果当前有消费者挂了，这时候需要重新瓜分下队列的归属，留存的消费者需要顶上挂了的消费者负责的队列，也就是需要重平衡。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/9-7.png"></p>
<p>当然，不仅仅是挂了之后要重平衡，新的消费者加入也会触发这个动作。</p>
<p>Broker知晓新消费者上线后，会通知一个组的消费者进行重平衡，默认每个消费者20s也会主动进行一次重平衡。</p>
<p>这是属于<strong>客户端的负载均衡</strong>。</p>
<p>重平衡后，每个消费者知道自己需要拉取哪个队列的消息，构建对应的请求去Broker拉取即可然后还有个<strong>消费进度</strong>的概念。</p>
<p>由于<strong>集群模式</strong>下，Topic下的队列是被消费组内的消费者瓜分的，如果发生老的消费者下线，或者新的消费者上线都需要重平衡，即每个 consumer 负责的队列会发生变化。</p>
<p>因此接手新队列的consumer需要知道老consumer对当前队列的消费进度，总不能发生重平衡后让新 consumer 从这个队列的最早的一条消息开始消费吧？</p>
<p>所以<strong>集群模式</strong>下，消费进度需要保存在 Broker 中，这样重平衡之后 consumer 可以从 Broker 知晓消费进度。</p>
<p>消费进度的更新是 consumer去Broker拉取请求时顺带将当前的消费进度带上去给Broker的。</p>
<p>而<strong>广播模式</strong>下，消费者之间的没有互帮互助的关系，各管各的，所以消费进度仅保存在它们本地。</p>
<p>如果消息消费失败了怎么办？</p>
<p>consumer 会将消息发回给 Broker，消息的 Topic 为%RETRY%+ConsumeGroupName，后续会重新消费这个消息。</p>
<p>如果一直消费失败，默认重试 16 次后，消息会进入死信队列，不会再进行重试。</p>
<h2 id="串联起来（重点）"><a href="#串联起来（重点）" class="headerlink" title="串联起来（重点）"></a>串联起来（重点）</h2><p>nameSrv 启动后，待命。</p>
<p>Broker 启动，将自身的信息包括IP、端口、Topic等上传给 nameSrv，等待 producer 发送消息，等待 consumer 消费消息。</p>
<p>producer 启动，连上 nameSrv，从它身上获取 Broker 信息，跟对应的 Broker 建立连接，建连后发送消息给 Broker。</p>
<p>Broker将消息存储到 commitlog 文件中，并分发到 consumerQueue，等待 consumer来消费拉取消息。</p>
<p>consumer 启动，连上nameSrv，从它身上获取 Broker 信息，跟对应的Broker建立连接，建连后发送拉取请求给 Broker。</p>
<p>Broker 根据对应的Topic、队列ID和消息点位，找到 consumerQueue 的消息，再解析找到对应commitlog 得到消息内容，然后返回给 consumer。</p>
<p>consumer 消费消息，随后上报自己的消费进度给 Broker。</p>
<p>以上，就是消息在消息队列生产、消费的关键链路流程。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>至此有关 RocketMQ必要组件的介绍和一些基本概念都已经聊的差不多了。</p>
<p>主要基于RocketMQ来介绍有关消息队列的设计，不同消息队列的具体实现肯定是有不同的，但是本质上的原理都是大差不差的，这里主要还是以RocketMQ为主。</p>
<p>之所以选择 RocketMQ 是因为在业务侧来说，它的性能很OK、提供的功能也很丰富，比如延迟消息、事务消息，这些都是 Kafka 没有的。</p>
<p>后面会更进一步地介绍这些特性的原理！</p>
<p>这篇文章把之前提到的一些要点都带了一遍，借着这个小总结可以巩固一下对这些基本概念和主流程的理解。</p>
<h1 id="消息队列-延迟消息的实现原理"><a href="#消息队列-延迟消息的实现原理" class="headerlink" title="消息队列-延迟消息的实现原理"></a>消息队列-延迟消息的实现原理</h1><p>今天我们来学习下，RocketMQ 的特性功能之延迟消息的实现原理。</p>
<p>前面，我们已经简单了解过延迟消息，即生产者给一条消息设置延迟时间，看起来消息是延迟这么久之后才被发送出去，然后消费者才能消费到这条消息。</p>
<p>常见的场景就是订单自动取消场景，下单后 15 分钟如果订单没支付，则自动取消订单，这个场景就可以用延迟消息实现。</p>
<p>那么延迟消息该如何实现呢？</p>
<h2 id="思考下如何设计"><a href="#思考下如何设计" class="headerlink" title="思考下如何设计"></a>思考下如何设计</h2><p>正常生活中，如果我们要延迟做一件事情，比如饭后半小时吃药，那么我们可能在吃饭时候需要设置个闹钟，半小时之后提醒我们该吃药了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-1.png"></p>
<p>映射到消息中来，是不是我们发送一条延迟消息，实际上也是在生产者内部设置个“闹钟”？等到时间了再投递出去呢？</p>
<p>不是的，如果让生产者来设定这个闹钟，那么成千上万个延迟消息的管理，需要多少个“闹钟”？</p>
<p>单设置闹钟就会给生产者制造很多压力，更别说那些堆积着没被发送出去的延迟消息，它们会把生产者的内存撑爆。</p>
<p>所以首先我们可以明确一点：<strong>延迟消息也是立马被投递出去的，而不是到了时间后才被生产者将消息发往 Broker。</strong></p>
<p>好了，压力给到了 Broker，这也符合 Broker 本身的定位：承载堆积大量消息，削峰填谷。现在 Broker 接收到延迟消息，它需要控制未到时间的消息不会被消费者消费，等到了时间后才能被消费者拉取到。</p>
<p>但是，Broker 也承载不了一个消息对应一个“闹钟”来管理的机制啊！</p>
<p>因为消息的量级可能很大（十万、百万、千万），如果每一个延迟消息都对应有一个“闹钟”，Broker 也是顶不住的。</p>
<p>并且，我们之前已经了解到，消息投递到 Broker 都是统一顺序存储在 commitlog 里，然后顺序映射到 consumerQueue 供消费者消费。</p>
<p>那延迟消息还能走这一套存储消费机制吗？</p>
<p>假设有一个消息延迟的时间是 1 天，它被夹在两条不延迟的消息中间，如果按<strong>顺序</strong>来看，后面的那条消息不是被堵住了吗？</p>
<p>因为消息的消费是按照 offset 确定位置的，当消费到延迟的这条消息，由于时间还没到，所以不让消费。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-2.png"></p>
<p>此时总不能堵着不让消费后面正常的消息吧？如果要消费到后面的消息，那么 offset 需要加1。</p>
<p>加 1 当然没问题，但是 offset + 1 后，就顺着往后消费了，offset 一直递增，然后等时间到了，再把 offset 调回来？</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-3.png"></p>
<p>调回来消费完了，再变回去？</p>
<p>是不是觉得这样的设计非常怪，如果延迟消息很多，那么就需要来回跳来跳去，整体设计的复杂度就会增加很多。</p>
<p>而且对于性能而言，也差！</p>
<p>因为在计算机领域有个<strong>局部性原理</strong>。</p>
<p>大概的意思就是最近访问到的数据，它附近的数据近期也会被访问，所以操作系统等层面的实现上都会做<strong>预加载</strong>的缓存操作。</p>
<p>拿数组举例：如果数组数据存储在硬盘，此时你访问了下标为 1 的数据，实际操作系统可能会把后面 2-10 的数据也都从磁盘加载到缓存里。</p>
<p>这样紧接着你访问下标为 2 的数据就直接从缓存里面拿，不需要从磁盘加载，就很快。</p>
<p>那么回到延迟消息offset来回跳的问题，就等于你访问了下标1，操作系统好心预加载了后面2-10的数据，紧接着你下次的访问下标跳到 100，操作系统又好心预加载了 101-110的数据。</p>
<p>后面你又跳到 50…</p>
<p>这样一来性能就差了，用不上预加载的缓存，去磁盘拿数据就很慢。</p>
<p>所以看起来好像无法直接复用 commitlog 那一套存储机制，这样一来不是得为延迟消息再设计一套消息的存储和消费模型啊！</p>
<p>这样太麻烦了。</p>
<p>那RocketMQ是如何设计的呢？</p>
<h2 id="粗说RocketMQ的设计"><a href="#粗说RocketMQ的设计" class="headerlink" title="粗说RocketMQ的设计"></a>粗说RocketMQ的设计</h2><p>针对“闹钟”撑爆的问题，RocketMQ 直接约定了一些延迟时间，即生产者无法灵活的自定义延迟时间，而是固定的几个延迟时间来供生产者选择：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-4.png"></p>
<p>可以看到一共有18个延迟时间供选择，基本已经满足日常业务的使用。</p>
<p>这样延迟消息也有统一归类和约束，便于管理和调配。</p>
<p>虽说归类了延迟消息，但是同一个延迟 level 的消息共用一个闹钟也是无法满足需求的。</p>
<p>所以变成专门雇一个“人”，每个“人”管一个level 的延迟消息，定时查看是否有到期的消息，如果到了立马让消息给消费者消费。</p>
<p>至于复用 commitlog 这一套的问题，<strong>专门搞个存放延迟消息的 Topic</strong>，延迟消息先发往这个Topic，消费者并不会订阅这个 Topic，因此此时消费者无法消费到这条消息。</p>
<p>等延迟消息到达时间后，Broker将这个延迟消息发往原Topic，此时消费者就能从原Topic消费到这条消息！</p>
<p>也就是说 Broker 自己建立一个专门 Topic 用来存放延迟消息，此时延迟消息的存储能复用commitlog 这一套模型，消息也会被分发到 consumeQueue。</p>
<p>不同的延迟level的消息会存放到这个Topic不同的队列中，也就是说这个Topic一共有18个队列对应 18 个 level。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-5.png"></p>
<p>然后会有一个定时线程去每个队列按序检查消息是否到时间了，如果到了就发到消息原先的Topic中。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-6.png"></p>
<h2 id="细说-RocketMQ-的设计"><a href="#细说-RocketMQ-的设计" class="headerlink" title="细说 RocketMQ 的设计"></a>细说 RocketMQ 的设计</h2><p>延迟消息的发送很简单，仅需设置一个 delayTimeLevel 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span>+ i). getBytes());</span><br><span class="line">message. setDelayTimeLevel (<span class="number">3</span>) ;</span><br><span class="line">producer. send (message) ;</span><br></pre></td></tr></table></figure>

<p>Broker 收到这个消息后，一看 delayTimeLevel 设置了值，那么就知道它是一个延迟消息，于是乎直接来个偷梁换柱！</p>
<p>把消息的原Topic和对应队列ID保存在消息扩展属性里面。</p>
<p>然后把这条消息的Topic设置成<code>SCHEDULE_TOPIC_XXXX</code>，没错 Topic 的名字就是SCHEDULE_TOPIC_XXXX哈，后面就是 XXXX！并且根据消息的Level 选择SCHEDULE_TOPIC_XXXX下对应的队列。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-7.png"></p>
<p>这样一来延迟消息就存储好了。</p>
<p>然后 Broker 起了一个定时线程池，里面一共有 18 个核心线程，这个线程池的任务就是定时调度SCHEDULE_TOPIC_XXXX 下的每个队列的消息，一旦有到期的消息，就分发到原Topic 供消费者消费。</p>
<p>具体的做法是在初始时，每个队列都会对应被创建一个任务扔到线程池中，这些任务的内容就是根据传入的队列ID，得到对应的 consumeQueue，当然还有对应的 offset。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-8.png"></p>
<p>Broker 会定时保存 SCHEDULE_TOPIC_XXXX 下 consumeQueue 的消费 offset。</p>
<p>得到 consuemrQueue 和 offset，对应的就能获取延迟消息，这时候将延迟时间跟当前时间对比，就能判断是否到期。</p>
<p>如果到期了，就从消息扩展属性里面获取原 Topic 和对应队列 ID，然后投递到原队列中。</p>
<p>上面已经展示过的图表明的就是这个意思，这里再贴一下：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-9.png"></p>
<p>然后在代码上的实现是立马新建一个任务扔到线程池中，延迟时间是100ms，任务的入参会塞入更新后的 offset，这样线程就会继续消费后面的消息，如此往复循环。</p>
<p>当然，如果拿到的对应延迟消息还未到时间，那么 offset 不变，也立马新建一个任务塞入到线程池中，这样 100ms后又会来看这个消息是否到期。</p>
<p>可以看到，整个延迟消息设计就加了一个线程池，很巧妙地复用了正常消息的 commitlog 和comsumeQueue 的存储机制，且利用发布订阅的特性，改变消息的 Topic 来使得消费者无法消费到未到时间的消息。</p>
<p>到时间了又投递回原 Topic 使得消费者可以消费到期的消息，非常 nice！</p>
<h2 id="这样实现是否有什么问题？"><a href="#这样实现是否有什么问题？" class="headerlink" title="这样实现是否有什么问题？"></a>这样实现是否有什么问题？</h2><p>从实现层面来看，大大减少了延迟消息开发的复杂度，但是<strong>这样的实现对延迟时间来说是不准的</strong>。</p>
<p>首先，同一个延迟 level 的消息都入同一个队列，然后上一个延迟消息处理完之后继续处理下一个，如果同一时刻有大量的同一个level的延迟消息产生，那么它们都堆积在一个队列里面，一个一个处理，这样一来即使后面的消息到时间了也得排队等着。</p>
<p>这样的机制就做不到非常实时。</p>
<p>并且从SCHEDULE_TOPIC_XXXX分发至原Topic之后，假设原Topic本身就已经有很多消息堆积了，那么等消费者消费到这条消息的时候，时间也是有大大延迟的。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10-10.png"></p>
<p>当然，本身在大流量下对时间的把控是无法做到很准确的，不论什么方式，都会有延迟，无非就是延迟精度多少的问题。</p>
<p>有一种比较好的定时结构就是时间轮了，这个我之前写过一篇文章，有兴趣的同学可以看看：时间轮算法</p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>这里我们学习了 RocketMQ 延迟消息的实现原理，这种<strong>偷梁换柱</strong>来复用原先的存储和消费逻辑非常巧妙，值得我们细细品味。</p>
<p>其实利用定时线程池来实现延迟消息到期的触发已经是 RocketMQ 优化后的实现了，一开始用的是 Timer。</p>
<h2 id="思考-7"><a href="#思考-7" class="headerlink" title="思考"></a>思考</h2><p>定时线程池的实现对比Timer 的实现有什么优势呢？</p>
<p><strong>解答：</strong></p>
<p>定时线程池相对于Timer的实现在某些方面具有一些优势：</p>
<ol>
<li><p>线程管理：定时线程池使用线程池来管理任务，而Timer则使用单个线程。线程池可以有效管理线程的生命周期，重用线程并避免创建过多线程，从而减少资源消耗。</p>
</li>
<li><p>线程安全性：定时线程池是线程安全的，多个任务可以同时执行而不会相互干扰。而Timer类在执行任务时是基于单个线程的，如果一个任务执行时间过长，可能会延迟其他任务的执行。</p>
</li>
<li><p>精确性：定时线程池使用<code>ScheduledExecutorService</code>来执行任务，可以提供更精确的时间调度。相比之下，Timer类在处理任务时依赖系统的计时器，可能存在一些时间误差。</p>
</li>
<li><p>异常处理：定时线程池可以更好地处理任务执行过程中的异常。如果一个任务在执行时抛出异常，线程池可以捕获并处理异常，而Timer类在遇到异常时只能终止运行。</p>
</li>
</ol>
<p>综上所述，定时线程池相对于Timer的实现具有更好的线程管理、线程安全性、精确性和异常处理能力。这些优势使得定时线程池在实现RocketMQ延迟消息等场景中更可靠和高效。</p>
<h1 id="消息队列-延迟消息的实现原理-1"><a href="#消息队列-延迟消息的实现原理-1" class="headerlink" title="消息队列-延迟消息的实现原理"></a>消息队列-延迟消息的实现原理</h1><p>这篇我们来学习下RocketMQ事务消息的作用以及它的实现原理。</p>
<p>这个事务消息也是我们常说的分布式事务的一种解决方案，在实际生产上有很多场景都能用到事务消息，比较常见。</p>
<p>包括在面试中也是常问的一个方向，需要我们好好掌握。</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>简单理解事务是指一系列的操作全部执行成功，或者全部失败，不会出现一些成功一些失败的情形。</p>
<p>经典的例子就是转账：A 转给 B 1000元，那么从 A 账户扣 1000 和往 B 账户打 1000 这两件事必须全部成功，要么全部失败，不然这个钱就对不上账了。</p>
<p>当然，按照正常科班教育，说到事务肯定就是ACID，就是指事务必须具备：原子性、一致性、隔离性和持久性。</p>
<p>这个是事务的严格定义，我们理解即可。</p>
<h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>一般在大学时候，所说的事务更多是数据库层面的，例如一个操作需要插入A、B两张表，A表是这个人的姓名等身份信息，B 表是这个人对应的住址邮编等信息，这两张表都在一个数据库中。</p>
<p>如果是正常流程，那么一个人A、B 两张表的记录都需保存成功。</p>
<p>如果出现异常情况，那么要保证 A、B两张表的记录都不能插入，不然就可能出现这个人有身份信息，但是没住址信息，或者有住址信息，没身份信息。</p>
<p>这个时候就可以用事务来保证两个操作的一致性。</p>
<p>但是在企业级场景，偏向互联网层面的公司用的都是微服务架构，因为扩展性和性能原因，很多情况下多个操作涉及的数据都存在不同的数据库中。</p>
<p>好比订单和商品，分别对应订单服务和商品服务，它们都有各自的数据库。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-1.png"></p>
<p>如果一个用户下单成功，那么同时就需要扣减对应商品的库存，这两个操作同样需要保证一致性，也就是得上事务。</p>
<p>我们前面提到的A.B两个表，因为这两张表都在一个数据库中，所以可以用数据库自身的机制来保证事务。</p>
<p>但是现在订单和商品分别属于不同的数据库，这个时候就用不上数据库自身的事务了，于是乎只能上<strong>分布式事务</strong>。</p>
<p>简单来说，能实现上述场景中下单成功和扣库存的事务性的操作，就叫分布式事务。</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>实现分布式事务的方案有很多，比如：2PC、3PC、TCC、本地消息、事务消息。</p>
<p>这篇我们讲的就是<strong>事务消息</strong>。</p>
<p>事务消息更适合应用在<strong>异步更新</strong>场景，用来保证<strong>最终一致性</strong>。</p>
<p>最终一致性的意思就是<strong>可能某一时刻两端数据是不一致的</strong>，比如 A 账户钱扣了，而 B 账户钱也还没进来，但是<strong>最终</strong>能保证 A 扣的 1000 一定会打到 B 账户上。</p>
<p>也就是说事务消息的实时性不高，在强实时性场景下这个方案就不合适了。</p>
<p>但是在对数据实时性要求不高的场景，就很 nice了。</p>
<p>比如哪个场景呢？</p>
<p>举一个我们每天都要操作的点外卖场景。</p>
<p>我们每次点外卖需要先选择食物加入到购物车，然后下单、付款，接着就等着拿外卖了。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-2.png"></p>
<p>但你有没有想过，下单后，之前你加入到购物车的数据，是需要被清理掉的呢？</p>
<p>最简单的方式就是在下单时候同步调用购物车清除接口来清理数据，但是这<strong>会增加下单时的耗时</strong>。</p>
<p>并且购物车所属接口的可能是另一个服务，那么因为网络原因，很可能购物车清除成功了，但是返回请求超时。</p>
<p>这时候同步的下单流程就报错了，下单失败，然后用户返回外卖店铺页面一看，呀！加到购物车里面的东西怎么都没了！这样体验就很不好。</p>
<p>这个场景就非常适合<strong>异步</strong>的事务消息，也就是保证我们下单成功后，购物车的数据一定会被清理且不增加下单接口的整体耗时。</p>
<p>看到这可能有同学会有疑问，用普通消息不就能实现这个功能了吗？</p>
<p>数据库插入订单数据后，发送一条消息让购物车清除数据不就行了，用得着用啥事务消息吗？</p>
<p>是的，简单想想从流程上好像没毛病，但是那是正常流程，一旦出现异常的情况，那就不好说了。</p>
<p>因为数据库相关操作可以利用数据库自身的实现保证数据库层面的数据一致性。</p>
<p>最最简化版的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、 savexxx ();</span><br><span class="line">2、 saveOrder();</span><br><span class="line">3、 sendMQToClearCart ();</span><br></pre></td></tr></table></figure>

<p>savexxx 和 saveOrder如果操作的表在同一个库内，可以保证数据库层面的事务性。</p>
<p>但是发送消息完全不属于数据库的范畴，这时候就保证不了了。</p>
<p>很有可能1、2、3步执行下来都是ok 的，这样一来消息已经发送出去了。</p>
<p>但是最后提交事务的时候报错了，这时候1、2两步回滚了，但是消息已经发出了啊！也就说购物车已经被清理了，这不就出问题了吗！</p>
<p>所以普通消息无法满足这个需求，这时候就得上事务消息，来保证下单和发送删除购物车数据的消息要么都成功，要么都失败！</p>
<h2 id="如何实现事务消息"><a href="#如何实现事务消息" class="headerlink" title="如何实现事务消息"></a>如何实现事务消息</h2><p>实际上 RocketMQ 实现事务消息的原理很简单，前面我们已经提到，主要就是异常的场景才容易导致事务的不一致，因此主要解决的矛盾就是异常的情况。</p>
<p>在事务开始时，我们就发送一条<strong>半消息</strong>（half message）给 Broker，所谓的半消息从字面理解就是不完整的消息，这种消息不会被消费者消费到。</p>
<p>然后执行本地事务，在我们举例的场景就是下单的一系列操作。</p>
<p>最后根据本地事务的执行结果来决定是向 Broker 发送提交消息，还是发送回滚消息。</p>
<p><strong>如果发送提交消息</strong>，那么半消息就会变“完整”，即可被消费者消息，最终消费者消费这条消息，整个分布式事务就完整了，保证了最终一致性。</p>
<p><strong>如果发送回滚消息</strong>，那么这条半消息就废了，不会被消费者消费到，这就跟本地事务结果保持一致。</p>
<p>看到这可能有人会说，如果出现什么意外，导致执行本地事务后，没有进一步发送提交或者回滚消息怎么办？如果本地事务失败了还行，但是如果执行是成功了，那么半消息不就一直不会被消费者消费了？</p>
<p>这时候数据就不一致了！</p>
<p>因此针对这种情况，RocketMQ还设计了一个反查机制：<strong>Broker会向发送的生产者来反查这个事务是否成功</strong>。</p>
<p>具体的实现是生产者暴露一个接口，通过这个接口 Broker 可以得知事务到底有没有执行成功，没成功就返回回滚。</p>
<p>当然因为有可能事务还在执行中，这时候可以返回 UNKOWN，这样 Broker 后续会继续查询，可以在接口逻辑上实现多次查询还未有结果再返回回滚。</p>
<p>按照上述的场景，生产者仅需提供一个查询订单是否存在的接口，如果订单存在说明下单成功，那么就提交消息事务，如果订单不存在那么可能是还未生成或者生成失败，那么多少次查询后还未生成就返回回滚即可。</p>
<p>还记得我们之前提到过的生产组（producer group）的概念吗？</p>
<p>Broker会反查生产者提供的接口，如果发送的生产者挂了，还有同一个生产组的其他生产者可以供 Broker 反查，这就是 producer group 的作用之一。</p>
<p>我之前写过文章画过一张流程图，这张图清晰的展示了RocketMQ事务消息的完整流程，后续会讲解具体的实现原理：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-3.png"></p>
<h2 id="如何使用-RocketMQ-事务消息"><a href="#如何使用-RocketMQ-事务消息" class="headerlink" title="如何使用 RocketMQ 事务消息"></a>如何使用 RocketMQ 事务消息</h2><p>在使用上，首先需要实现 RocketMQ 定义的 TransactionListener 接口：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-4.png"></p>
<p>一共有两个方法，一个方法是实现执行本地事务的逻辑，另一个方法是给 Broker 反查用的。</p>
<p>源码给了个演示的实现，可以看到代码还是很简单的，随机数生成状态模拟事务的成功和失败，然后将结果存储本地存储中，供反查时候使用：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-5.png"></p>
<p>实现类弄完了，实际的使用了。</p>
<p>这里的截图用的也是源码里面的示例，主要看我标记的地方就行：</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-6.png"></p>
<p>整体使用层面还是很简单的，发送消息的行为看起来跟正常的消息发送是一致的，无非前置需要配置一些东西罢了。</p>
<p>大概知晓原理和使用后，我们来看看RocketMQ的事务消息具体是如何实现的。</p>
<h2 id="RocketMQ实现原理"><a href="#RocketMQ实现原理" class="headerlink" title="RocketMQ实现原理"></a>RocketMQ实现原理</h2><p>其实事务消息的需求跟上篇的延时消息需求有点一致，都是在一定条件前无法被消费者消费，只有当条件成立后，才能被消费者消费。</p>
<p>因此事务消息可以跟延时消息用一样的套路。</p>
<p>即发送半消息的的时候，发往的不是原先的Topic，而是将发往特定的Topic：RMQ_SYS_TRANS_HALF_TOPIC</p>
<p>同样还是<strong>偷梁换柱</strong>，将原先的Topic和队列存储在属性里，替换Topic为RMQ_SYS_TRANS_HALF_TOPIC，队列默认为 0。</p>
<p>这样一来消息被存储后也不会被消费者消费。</p>
<p>然后等待生产者的提交或者回滚事务的请求，如果收到提交，那么从属性中获取消息原先的 Topic和队列，将消息发往原 Topic 即往 commitlog 里面存储这条消息，这样消费者就能消费到了。</p>
<p>如果是回滚，那么就不往 commitlog 里面存储，这样消费者就不会消费到，等同于事务回滚了。</p>
<p>并且 Broker 起了一个定时线程 TransactionalMessageCheckService 服务，它会定时的扫描RMQ_SYS_TRANS_HALF_TOPIC 这个 Topic 下的消息，去请求生产者的反查接口看看事务成功了没，如果成功就恢复原先的 Topic 供消费者消费，失败的话就不重新投递。</p>
<p><img src="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/11-7..png"></p>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>其实，RocketMQ 事务消息的实现，类似于两阶段提交的实现，先有个半消息，然后再决定提交还是回滚。</p>
<p>如果没接触过事务消息，可能会被这个名词给吓到，以为是多高深的东西，实际上理解了原理后，整体实现逻辑还是不难的。</p>
<p>当然，这个事务消息只是分布式事务的一种解决方案，但是是属于性能比较好的那种。</p>
<p>说到性能，其实很多时候为了性能，除了跟金钱有实际关系的场景，我们都能容忍一定的数据不一致，会选择通过定时扫描或者补偿了弥补这些不一致的数据。</p>
<p>而不是在业务处理中实时保证数据的一致性，因为这样的成本太高了。</p>
<p>好了，有关RocketMQ事务消息就说到这里，有什么疑惑和问题欢迎留言讨论。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">黯淡的晨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">http://example.com/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/%E6%98%9F%E7%A9%BA.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/06/09/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"><img class="next-cover" src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">SQL语句练习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E7%B4%AB%E7%81%B5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">黯淡的晨</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fzchen001" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:fzchen1999@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%88%9D%E5%A7%8B%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">消息队列-初始篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">消息队列的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.2.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">消息队列-必须掌握的两个基础模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">队列模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">发布-订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%B6%88%E6%81%AF%E5%8F%91%E5%BE%80%E5%93%AA%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">生产者如何确定消息发往哪个队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-1"><span class="toc-number">2.5.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8B%E5%AD%98%E5%82%A8%EF%BC%881%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">消息队列-核心之存储（1）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%93%AA%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">消息存哪？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98%EF%BC%81"><span class="toc-number">3.2.</span> <span class="toc-text">本地硬盘！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commitlog"><span class="toc-number">3.3.</span> <span class="toc-text">commitlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98"><span class="toc-number">3.4.</span> <span class="toc-text">机械硬盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-2"><span class="toc-number">3.6.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8B%E5%AD%98%E5%82%A8%EF%BC%882%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">消息队列-核心之存储（2）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ConsumeQueue"><span class="toc-number">4.1.</span> <span class="toc-text">ConsumeQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#consumerOffset"><span class="toc-number">4.2.</span> <span class="toc-text">consumerOffset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.</span> <span class="toc-text">消息索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8B%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">5.</span> <span class="toc-text">消息队列-核心之消息的发送</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.</span> <span class="toc-text">普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">同步消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.2.</span> <span class="toc-text">异步消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.3.</span> <span class="toc-text">单向消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">5.3.</span> <span class="toc-text">延迟消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number">5.4.</span> <span class="toc-text">批量消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-3"><span class="toc-number">5.6.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8BNameSrv"><span class="toc-number">6.</span> <span class="toc-text">消息队列-核心之NameSrv</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSrv-%E4%B8%8EBroker"><span class="toc-number">6.1.</span> <span class="toc-text">NameSrv 与Broker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSrv-%E4%B8%8EProducer"><span class="toc-number">6.2.</span> <span class="toc-text">NameSrv 与Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSrv-%E4%B8%8E-Consumer"><span class="toc-number">6.3.</span> <span class="toc-text">NameSrv 与 Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSrv-%E4%B8%8ENameSrv"><span class="toc-number">6.4.</span> <span class="toc-text">NameSrv 与NameSrv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-4"><span class="toc-number">6.6.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8B%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%EF%BC%881%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">消息队列-核心之消息的消费（1）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E6%AF%94%E5%BF%AB%E9%80%92"><span class="toc-number">7.1.</span> <span class="toc-text">消息对比快递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.</span> <span class="toc-text">推消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E6%B6%88%E6%81%AF"><span class="toc-number">7.3.</span> <span class="toc-text">拉消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%BF%98%E6%98%AF%E6%8B%89%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">推还是拉？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E7%9A%84push%E5%92%8Cpull"><span class="toc-number">7.5.</span> <span class="toc-text">RocketMQ的push和pull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">7.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-5"><span class="toc-number">7.7.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%A0%B8%E5%BF%83%E4%B9%8B%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%EF%BC%882%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">消息队列-核心之消息的消费（2）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8"><span class="toc-number">8.1.</span> <span class="toc-text">消费者启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8B%89%E6%B6%88%E6%81%AF"><span class="toc-number">8.2.</span> <span class="toc-text">如何拉消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%82%B9%E4%BD%8D%EF%BC%88offset%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">消息点位（offset）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">广播模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">集群模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">8.4.</span> <span class="toc-text">如何消费消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-6"><span class="toc-number">8.6.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number">9.</span> <span class="toc-text">消息队列-阶段总结篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">9.1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Broker"><span class="toc-number">9.2.</span> <span class="toc-text">Broker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#producer%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">producer（生产者）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#consumer%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">consumer（消费者）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E8%B5%B7%E6%9D%A5%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">9.5.</span> <span class="toc-text">串联起来（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">9.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">消息队列-延迟消息的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.1.</span> <span class="toc-text">思考下如何设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%97%E8%AF%B4RocketMQ%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.2.</span> <span class="toc-text">粗说RocketMQ的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%AF%B4-RocketMQ-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.3.</span> <span class="toc-text">细说 RocketMQ 的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0%E6%98%AF%E5%90%A6%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">这样实现是否有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83-7"><span class="toc-number">10.6.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">11.</span> <span class="toc-text">消息队列-延迟消息的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.1.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.2.</span> <span class="toc-text">什么是分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">11.3.</span> <span class="toc-text">事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">11.4.</span> <span class="toc-text">如何实现事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-RocketMQ-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">11.5.</span> <span class="toc-text">如何使用 RocketMQ 事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.6.</span> <span class="toc-text">RocketMQ实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">11.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列"><img src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息队列"/></a><div class="content"><a class="title" href="/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列">消息队列</a><time datetime="2023-06-14T04:15:41.000Z" title="Created 2023-06-14 12:15:41">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/09/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/" title="SQL语句练习"><img src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL语句练习"/></a><div class="content"><a class="title" href="/2023/06/09/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/" title="SQL语句练习">SQL语句练习</a><time datetime="2023-06-09T05:33:31.000Z" title="Created 2023-06-09 13:33:31">2023-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记"><img src="/img/%E4%BC%91%E9%97%B2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习笔记"/></a><div class="content"><a class="title" href="/2023/05/29/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记">MySQL学习笔记</a><time datetime="2023-05-29T05:17:19.000Z" title="Created 2023-05-29 13:17:19">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%BD%BF%E7%94%A8%20C#%20%E5%92%8C%20MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%98%E5%88%B6%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A/" title="No title"><img src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2023/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%BD%BF%E7%94%A8%20C#%20%E5%92%8C%20MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%98%E5%88%B6%E6%B3%A2%E5%BD%A2%E5%9B%BE%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A/" title="No title">No title</a><time datetime="2023-04-07T07:18:13.896Z" title="Created 2023-04-07 15:18:13">2023-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="/img/%E4%BC%91%E9%97%B2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2023-03-27T06:47:41.000Z" title="Created 2023-03-27 14:47:41">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E6%98%9F%E7%A9%BA.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 黯淡的晨</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://fzchen001.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/'
    this.page.identifier = '/2023/06/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/'
    this.page.title = '消息队列'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>